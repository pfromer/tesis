\documentclass[11pt,a4paper,twoside]{tesis}
% SI NO PENSAS IMPRIMIRLO EN FORMATO LIBRO PODES USAR
%\documentclass[11pt,a4paper]{tesis}

\usepackage{graphicx}
\graphicspath{ {images/} }
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage[left=3cm,right=3cm,bottom=3.5cm,top=3.5cm]{geometry}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[T1]{fontenc}
\newtheorem{exmp}{Ejemplo}
\usepackage[linesnumbered,titlenumbered,ruled]{algorithm2e}
\usepackage{bera}
\usepackage{listings}
\usepackage{xcolor}
\usepackage[shortlabels]{enumitem}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}

\colorlet{punct}{red!60!black}
\definecolor{background}{HTML}{EEEEEE}
\definecolor{delim}{RGB}{20,105,176}
\colorlet{numb}{magenta!60!black}

\lstdefinelanguage{json}{
    basicstyle=\normalfont\ttfamily,
    numbers=left,
    numberstyle=\scriptsize,
    stepnumber=1,
    numbersep=8pt,
    showstringspaces=false,
    breaklines=true,
    frame=lines,
    backgroundcolor=\color{background},
    literate=
     *{0}{{{\color{numb}0}}}{1}
      {1}{{{\color{numb}1}}}{1}
      {2}{{{\color{numb}2}}}{1}
      {3}{{{\color{numb}3}}}{1}
      {4}{{{\color{numb}4}}}{1}
      {5}{{{\color{numb}5}}}{1}
      {6}{{{\color{numb}6}}}{1}
      {7}{{{\color{numb}7}}}{1}
      {8}{{{\color{numb}8}}}{1}
      {9}{{{\color{numb}9}}}{1}
      {:}{{{\color{punct}{:}}}}{1}
      {,}{{{\color{punct}{,}}}}{1}
      {\{}{{{\color{delim}{\{}}}}{1}
      {\}}{{{\color{delim}{\}}}}}{1}
      {[}{{{\color{delim}{[}}}}{1}
      {]}{{{\color{delim}{]}}}}{1},
}

\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
   language=JavaScript,
   backgroundcolor=\color{lightgray},
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=c
}

\newcommand{\ch}{\textit{chase}}

\newcommand{\parteEntera}{\lfloor n/2 \rfloor}
\newcommand{\reapairs}{\textit{repairs }}
\newcommand{\reapair}{\textit{repair }}
\newcommand{\reapairsGrandes}{\textit{repairsGrandes }}
\newcommand{\reapairsChicos}{\textit{repairsChicos }}
\newcommand{\reapairsFinder}{\textit{repairsFinder }}

\newcommand{\nBottom}{\textit{nBottom }}
\newcommand{\nTop}{\textit{nTop }}
\newcommand{\ttop}{\textit{top }}
\newcommand{\bottom}{\textit{bottom }}
\newcommand{\iterarBottom}{\textit{IterarBottom }}
\newcommand{\iterarTop}{\textit{IterarTop }}
\newcommand{\proximoBottom}{\textit{proximoBottom }}
\newcommand{\culprits}{\textit{culprits }}
\newcommand{\culprit}{\textit{culprit }}

\begin{document}


%%%% CARATULA

\def\autor{Pablo Víctor Fromer}
\def\tituloTesis{Datalog +/-, \vspace{.2cm} \\ una interfaz tolerante a la inconsistencia }
\def\runtitulo{Datalog +/-, una interfaz tolerante a la inconsistencia}
\def\runtitle{Datalog +/-, una interfaz tolerante a la inconsistencia}
\def\director{María Vanina Martinez}
\def\codirector{Ricardo Oscar Rodriguez}
\def\lugar{Buenos Aires, 2019}
\input{caratula}

%%%% ABSTRACTS, AGRADECIMIENTOS Y DEDICATORIA
%\frontmatter
%\pagestyle{empty}
%\input{abs_esp.tex}

%\cleardoublepage
%\input{abs_en.tex} % OPCIONAL: comentar si no se quiere

%\cleardoublepage
%\input{agradecimientos.tex} % OPCIONAL: comentar si no se quiere

%\cleardoublepage
%\input{dedicatoria.tex}  % OPCIONAL: comentar si no se quiere

\cleardoublepage
\tableofcontents

\mainmatter
\pagestyle{headings}

%%%% ACA VA EL CONTENIDO DE LA TESIS

\chapter{Introducción}
\section{Motivación}

Durante mucho tiempo y en distintas disciplinas dentro de las ciencias de la computación se ha estudiado el problema de cómo manejar información conflictiva o inconsistente. En los últimos años, ha habido un creciente interés en este tema con el advenimiento de la \textit{Web Semántica}, que ha hecho que este asunto sea aún más relevante; teniendo en cuenta que en ambientes abiertos, con fuentes de información proveniente de diversos orígenes, es habitual que surjan contradicciones entre los datos.

Por otro lado, es bien sabido que la inconsistencia también genera problemas en la lógica clásica. En particular, las teorías lógicas de primer orden inconsistentes no tienen modelos, y por lo tanto implican todas las fórmulas; con lo cual, responder consultas en una base de conocimientos inconsistente carece de sentido. Esto llevó a que en el campo de la inteligencia artificial y de la teoría de base de datos, se haya mantenido tradicionalmente la postura de que las bases de conocimiento deberían ser totalmente libres de información inconsistente, y que esta debería ser erradicada inmediatamente. Sin embargo, en las últimas décadas, se ha reconocido que para muchas aplicaciones interesantes aquella postura es obsoleta. 

Existen dos enfoques para lidiar con la inconsistencia: el primero consiste en que dada una base de conocimiento inconsistente, se debe arreglarla de una manera optimal;  lo cual puede implicar cambios en la teoría lógica subyacente tanto como agregar o quitar sentencias de la base. Este enfoque se caracteriza por tener una ``nocion coherentista'' en la que nos quedamos con una nueva base de datos que reemplaza a la original.  
El segundo enfoque se basa en considerar todas las maneras posibles de arreglar esa base de conocimientos \textit{on the fly}, es decir al momento de realizar las consultas. De alguna manera se ``convive'' con la inconsistencia. En este trabajo nos concentraremos en el segundo enfoque.

Distintas aproximaciones se pueden considerar también al momento de erradicar la consistencia; existen para esto diferentes semánticas, algunas más restrictivas que otras, y con diferente grado también de complejidad computacional. Queremos presentar aquí los diferentes enfoques que se han propuesto en este campo, y presentar también un algoritmo que ayude a resolver el problema de la inconsistencia de manera eficiente. Teniendo en cuenta que la semántica \textit{AR}, es la semántica más aceptada para \textit{query answering} en ontologías potencialmente inconsistentes, nuestra intención es proponer una estrategia algorítmica eficiente que permita responder consultas bajo esta semántica.
Por otro lado, nuestra motivación se basa también en presentar una herramienta que le permita al usuario poder explorar distintas semánticas para respuesta a consultas y comparar resultados.

Enmarcaremos este problema en el contexto de \textit{Datalog +/-}, una familia de extensiones de \textit{Datalog}, que se ha propuesto como un nuevo paradigma para responder consultas sobre ontologías. Esta familia de extensiones permite cuantificar variables existencialmente en la implicaciones lógicas, siendo esto una forma de \textit{generar} nuevo conocimiento, como ejemplificaremos en las siguientes páginas. Además, con algunas restricciones sintácticas que rigen sobre los diferentes \textit{fragmentos} de esta familia, se ha demostrado que se puede lograr tratabilidad y eficiencia computacional, lo cual hace que \textit{Datalog +/-} sea lo suficientemente atractivo para el campo de la inteligencia artificial y las bases de datos. Nos entusiasma por lo tanto presentar una herramienta que no solo permita responder consultas sobre ontologías inconsistentes sino que además acerque \textit{Datalog +/-} al público general de manera amigable. 



\section{Datalog +/-}\label{seccion_datalog}

En esta sección vamos a recordar los elementos principales del lenguaje Datalog tal como se definen en el artículo \textit{A General Datalog-Based Framework for
Tractable Query Answering over Ontologies}\cite{JWS}.
Con respecto a los ingredientes elementales, se asumen constantes, nulos y variables de la siguiente manera; estos son los argumentos de las fórmulas atómicas en las bases de datos, consultas y dependencias.
Se asume (i) un universo infinito de constantes  $\Delta$ (las cuáles forman el dominio de la base de  datos), (ii) un conjunto infinito de nulos etiquetados $\Delta_{N}$ (representando valores desconocidos), y (iii) un conjunto infinito de variables X (que se utilizan en las consultas y en las dependencias). Cada constante representa un valor diferente, mientras que nulos distintos podrían representar el mismo valor. 
Se asume un orden lexicográfico en  $\Delta \cup \Delta_{N}$, donde los símbolos de $\Delta_{N}$ siguen a los de $\Delta$. Se denota por $X$ a una sequencia de variables $X_{1}$, ..., $X_{K}$ con $k > 0$.

Se definen las fórmulas atómicas, que ocurren en bases de datos, consultas, y dependencias, y que se construyen en base a los nombres de las relaciones y los términos. Se asume un \textit{esquema relacional $R$}, el cual constituye un conjunto finito de \textit{nombres de relación}, o \textit{símbolos de predicado}. La posición \textit{P[i]} identifica al \textit{i}-esimo argumento de un predicado \textit{P}. Un \textit{término t} es una constante, un nulo o variable. Una \textit{fórmula atómica} (o \textit{átomo}) \textit{a} tiene la forma \textit{P}($t_{1}$,...,$t_{n}$), donde \textit{P} es un predicado $n$-ario, y $t_{1}$,...,$t_{n}$ son términos. Se denotan por \textit{pred}(\textit{a}) y \textit{dom(a)} su predicado y al conjunto de sus argumentos, respectivamente. Esta notación se extiende de manera natural para conjuntos y conjunciones de átomos. 

Podemos definir ahora la noción de base de datos relativa a un esquema relacional, junto con la sintaxis y la semántica de las consultas conjuntivas y las consultas conjuntivas booleanas a una base de datos. Una \textit{instancia de base de datos} $D$ para un esquema relacional $R$ es un conjunto de átomos (posiblemente infinito) con predicados de R y argumentos de $\Delta$. Una consulta conjuntiva sobre $R$ tiene la forma $Q(\textbf{X}) = \exists\textbf{Y}\Phi(\textbf{X},\textbf{Y})$, donde $\Phi(\textbf{X},\textbf{Y})$ es una conjunción de átomos con las variables \textbf{X} e \textbf{Y}, y eventualmente constantes, pero sin nulos. Una consulta conjuntiva \textit{Booleana} sobre $R$ es una consulta conjuntiva de la forma $Q() = \exists\textbf{Y}\Phi(\textbf{X},\textbf{Y})$, donde todas las variables están cuantificadas existencialmente. El conjunto de todas las respuestas a una consulta conjuntiva $Q(\textbf{X}) = \exists\textbf{Y}\Phi(\textbf{X},\textbf{Y})$ sobre una base de datos es el conjunto de todas las tuplas \textbf{t} sobre $\Delta$ para las cuales existe un homomorfismo $\mu: \textbf{X} \cup \textbf{Y} \rightarrow \Delta \cup \Delta_{N}$ tales que $\mu(\Phi(\textbf{X},\textbf{Y})) \subseteq D$ y $\mu(\textbf{X}) = \textbf{t}$

\begin{exmp}\label{ejemplo_base_d}
Consideremos una base de datos de películas, que guarda información acerca de actores, directores y películas. El esquema relacional $R$ consiste en los predicado unarios \textit{pelicula}, \textit{actor}, \textit{director},  y en los predicados binarios \textit{actuaEn}, \textit{dirigidaPor} y \textit{trabajaronJuntos}.  Una base de datos $D$ para el esquema  $R$ puede estar dada por: 
    \begin{equation}
        $$D = \{\textit{pelicula(``Volver al Futuro''), pelicula(``Esperando la Carroza''), actuaEn(``Esperando la Carroza'', ``Antonio Gasalla''), actuaEn(``Esperando la Carroza'', ``China Zorrilla''),
        actor(``Antonio Gasalla''), dirigidaPor(``Esperando la Carroza'', ``Alejandro Doria'')}\}$$
    \end{equation}

Un ejemplo de consulta conjuntiva para esta base de datos es: $$Q(X) = pelicula(X) \land \exists Y actuaEn(X, Y)$$ que pregunta por todas las películas en las que alguien haya actuado, cuya respuesta es el conjunto de una sola tupla \textit{\{(``Esperando la Carroza'')\}};  mientras que un ejemplo de consulta conjuntiva booleana es $$Q() =  actor(X) \land \exists X actuaEn(``Volver al Futuro'', X)$$ la cual pregunta si hay algún actor que haya actuado en Volver al Futuro, cuya respuesta es No.

\end{exmp}

\subsection{Dependencias generadoras de tuplas (TGDs)}
Las dependencias generadoras de tuplas (TGDs) son restricciones sobre una base de datos en la forma general de las reglas de Datalog+/-.
Dado un esquema relacional $R$, una TGD $\sigma$ es una fórmula de primer orden de la forma $\forall X \forall Y \Phi (X, Y) \rightarrow \exists Z \Psi (X, Z)$, donde $ \Psi (X, Z)$ y $\Phi (X, Y)$ son conjunciones de átomos sobre $R$, llamadas el \textit{cuerpo} y la \textit{cabeza} de $\sigma$, denotadas $cuerpo(\sigma)$ y $cabeza(\sigma)$ respectivamente. Tal $\sigma$ es satisfecha en una base de datos $D$ para $R$ ssi, toda vez que exista un homomorfismo $h$ que mapea los atomos de $\Phi(X, Y)$ a atomos de $D$, existe una extensión $h\prime$ de $h$ que mapea los atomos de $\Psi (X, Z)$ a átomos de $D$. Todos los conjuntos de $TGDs$ son finitos. Usualmente se omiten los cuantificadores universales en las TGDs.
\iffalse
\begin{exmp}
{\rb
    Tomando en cuenta el ejemplo anterior, un posible conjunto de TGDs parar $R$ puede estar dado por $\Sigma = \{\forall X pelicula(X) \rightarrow \exists Z dirigidaPor(X, Z), 
    \forall X \forall Y \forall W actuaEn(X, Y) \land dirigidaPor(X, W) \rightarrow \trabajaronJuntos(Y, W) \}$
    }
\end{exmp}   
\fi


\begin{exmp}\label{ejemplo_tgds}
    Tomando en cuenta el ejemplo anterior, un posible conjunto de TGDs parar $R$ puede estar dado por
\begin{itemize}
    \item Toda película fue dirigida por un director:  $$pelicula(X) \rightarrow \exists Z dirigidaPor(X, Z)$$
    \item Si alguien dirigió una película entonces es un director: $$dirigidaPor(X, Y) \rightarrow director(Y)$$
    \item Si alguien actuó en una película entonces es un actor: $$actuaEn(X, Y) \rightarrow actor(Y)$$
    \item Si un actor actuó en una película que fue dirigida por un director, eso implica que el actor y el director trabajaron juntos: $$actuaEn(X, Y) \land dirigidaPor(X, W) \rightarrow trabajaronJuntos(Y, W) $$ 
\end{itemize}

Es simple ver que ninguna de las TGDs anteriores es satisfecha en $D$. Consideremos entonces la base de conocimiento $D\prime$ que extiende a $D$ de la siguiente manera:

\begin{equation}
    $$ $D\prime$ = D $\cup$ \{\textit{dirigidaPor(``Volver al Futuro'', ``Robert Zemeckis''), director(``Robert Zemeckis''), actor(``China Zorilla''), director(``Alejandro Doria''), trabajaronJuntos(``Antonio Gasalla'', ``Alejandro Doria''), trabajaronJuntos(``China Zorilla'', ``Alejandro Doria'')}\}$$
\end{equation} 

Ahora todas las TGDs están satisfechas en $D\prime$.

\end{exmp} 

\subsection{Respondiendo consultas bajo TGDs}\label{consultas_bajo_tgds}

La evaluación de una consulta conjuntiva o una consulta conjuntiva booleana sobre una base de datos bajo un conjunto de TGDs se define de la siguiente manera. Dada una base de datos $D$ para $R$, y un conjunto de TGDs $\Sigma$ sobre $R$, el conjunto de modelos de $D$ y $\Sigma$, el cual denotamos por $mods(D,\Sigma)$, es el conjunto (posiblemente infinito) de todas las bases de datos $B$ tales que (i) $D \subseteq B$ y (ii) toda $\sigma \in \Sigma$ es satisfecha en $B$. El conjunto de todas las respuestas para una consulta conjuntiva $Q$, denotado por $ans(Q, D, \Sigma)$, es el conjunto de todas las tuplas \textit{a} tales que \textit{a} $\in Q(B)$ para todo $B \in mods(D, \Sigma)$. La respuesta para una consulta conjuntiva booleana $Q$ a $D$ es \textit{Sí}, denotada por $D \cup \Sigma \models Q$, si solo si, $ans(Q, D, \Sigma) \neq \emptyset$. Notar que responser consultas bajo TGDs para el caso general es indecidible \cite{beeri}, aún cuando el esquema y las TGDs son fijas \cite{cali}. 


\begin{exmp} \label{ejemplo_responder_consultas_bajo_tgds}
Si consideramos la base $D$ del ejemplo \ref{ejemplo_base_d} y las TGDs del ejemplo \ref{ejemplo_tgds} podemos ver que $D \notin mods(D, \Sigma)$ ya que como dijimos antes estas TGDs no se satisfacen en $D$. Por el contrario  $D\prime \in mods(D, \Sigma)$, es decir $D\prime$ es modelo de $D$ y $\Sigma$. En particular las siguientes bases de datos son dos de los modelos de  $D$ y $\Sigma$:   

\begin{itemize}
    \item 
      \(D_1\) = D \(\cup\) \{\textit{dirigidaPor(``Volver al Futuro'', ``Steven Spielberg''), director(``Steven Spielberg''),
    actor(``China Zorilla''), director(``Alejandro Doria''), trabajaronJuntos(``Antonio Gasalla'', ``Alejandro Doria''), trabajaronJuntos(``China Zorilla'', ``Alejandro Doria'')}\}
    \item  \(D_2\) = D \(\cup\)  \{\textit{dirigidaPor(``Volver al Futuro'', ``Robert Zemeckis''), director(``Robert Zemeckis''), actuaEn(``Volver al Futuro'', ``Michael J. Fox''), actor(``Michael J. Fox''), trabajaronJuntos(``Michael J. Fox'', ``Robert Zemeckis''),  actor(``China Zorilla''), director(``Alejandro Doria''), trabajaronJuntos(``Antonio Gasalla'', ``Alejandro Doria''), trabajaronJuntos(``China Zorilla'', ``Alejandro Doria'')}\}

\end{itemize} 

Notemos que el átomo \textit{película(``Volver al Futuro'')} está en todos los \textit{modelos} de $D$ y $\Sigma$\footnote{El átomo pertenece a $D$, entonces estará trivialmente en cualquier supraconjunto del mismo.}, por lo tanto la consulta conjuntiva boleana \textit{Q() = película(``Volver al Futuro'')} evalúa a \textit{Sí} en $D$ y $\Sigma$, y lo mismo ocurre con Q() = trabajaronJuntos(``China Zorrilla", ``Alegandro Doria"). Por el contrario, la consulta Q() = dirigidaPor(``Volver al Futuro", ``Robert Zemeckis") no es verdadera en todos los \textit{modelos} de $D$ y $\Sigma$\footnote{En particular no es verdadera en $D_2$.}, por lo tanto esta consulta evalúa a \textit{No}.
\end{exmp} 

Recordamos que el problema de evaluar una consulta conjuntiva bajo TGDs es LOGSPACE-equivalente al problema de evaluar una consulta conjuntiva booleana [\cite{Chandra}, \cite{Deutsch}, \cite{Fagin}, \cite{Johnson}]. Por eso nos enfocamos aquí solo en el problema de responder consultas conjuntivas booleanas. Recordamos también que responder consultas bajo TGDs es equivalente a responder bajo TGDs que tienen un solo átomo en sus cabezas. Por lo tanto, asumimos sin pérdida de generalidad, que toda TGD tiene un solo átomo en su cabeza.


\subsection{El chase}

El \textit{chase} es un procedimiento para reparar una base de datos con respecto a un conjunto de dependencias, de manera tal que el resultado del \textit{chase} satisfaga esas dependencias. Por \textit{chase} nos referimos tanto al procedimiento como a su resultado. El \textit{TGD chase} trabaja sobre una base de datos a través de aplicar las TGDs como se explica a continuación. Considere una base de datos $D$ para un esquema relacional $R$, y una TGD $\sigma$ sobre $R$ de la forma $\Phi (X, Y) \rightarrow \exists Z \Psi (X, Z)$. Entonces, $\sigma$ es \textit{aplicable} a $D$ si existe un homomorfismo \textit{h} que mapee los átomos de $\Phi (X, Y)$ a átomos de $D$. Sea $\sigma$ aplicable a $D$, y sea $h_1$ un homomorfismo que extiende \textit{h} de la siguiente manera: para cada $X_i \in \textbf{X}, h_1(X_i) = h(X_i)$; para cada $Z_j \in \textbf{Z}, h_1(Z_j) = z_j$, siendo $z_j$ un \textit{nulo fresco}, es decir, $z_j \in \Delta_N, z_j$ no ocurre en $D$, y $z_j$ sigue lexicográficamente a todos los otros nulos introducidos previamente. Al aplicar $\sigma$ a $D$, se agrega a $D$ el átomo $h_1(\Psi (X, Z))$, si no se encuentra en $D$ previamente.
El algoritmo del \textit{chase} para una base de datos $D$ y un conjunto de TGDs $\Sigma$ consiste en una aplicación exhaustiva de la regla anterior en anchura, lo cual trae como resultado un \textit{chase} (posiblemente infinito) para $D$ y $\Sigma$. Formalmente, el \textit{chase} de nivel 0 para $D$ y $\Sigma$, denotado por $chase^0(D,\Sigma)$, se define como $D$, asignándole a cada átomo de $D$ el nivel de derivación 0. Para cada $k \geq 1$, el chase de nivel $k$ de $D$ y $\Sigma$, denotado $chase^k(D, \Sigma)$, se construye de la siguiente manera: sean $I_1,...,I_n$ todas las posibles imágenes de los cuerpos de las TGDs en $\Sigma$ relativas a algún homomorfismo tal que (i) $I_1,...,I_n \subseteq chase^{k-1}(D,\Sigma)$ y (ii) el nivel más alto de todo átomo en cada $I_i$ es $k - 1$; entonces, se aplica cada posible TGD sobre $chase^{k-1}(D,\Sigma)$, escogiendo las TGDs y los homomorfismos en un orden lineal y lexicográfico respectivamente, y asignándole a cada átomo nuevo el nivel de derivación $k$. El chase de $D$ relativo a $\Sigma$, denotado $chase(D,\Sigma)$, se define entonces como el limite de $chase^k(D,\Sigma)$ para $K \rightarrow \infty$. 

El \textit{chase} (posiblemente infinito) es un modelo universal\cite{JWS}  de $D$ y $\Sigma$, es decir que existe un homomorfismo del $chase(D, \Sigma)$ a cada $B \in mods(D,\Sigma)$. Este resultado implica que las consultas conjuntivas boolenas sobre $D$ y $\Sigma$ pueden ser evaluadas en el chase para $D$ y $\Sigma$, es decir que $D \cup \Sigma \models Q$ es equivalente a $chase(D, \Sigma) \models Q$. 


\begin{exmp}\label{ejemplo_chase}

    Consideremos otra vez la base de datos $D$ del ejemplo \ref{ejemplo_base_d} y las TGDs del ejemplo \ref{ejemplo_tgds}, agregando ahora la TGD $actor(X) \land actuaEn(X, Y) \rightarrow \exists Z interpretoA(X, Y, Z)$; significando que el actor X, en la película Y interpretó al actor Z. 
    
    Entonces, en la construcción del chase $(D, \Sigma)$, iteramos de la siguiente forma.
    
    \begin{itemize}
        \item En la primera iteración obtenemos los siguientes átomos a través de las TGDs que se indican en cada paso.
        \begin{itemize}
            \item $pelicula(X) \rightarrow \exists Z dirigidaPor(X, Z)$:
            \begin{itemize}
                \item \textit{dirigidaPor(``Volver al Futuro'', $z_1$)}
            \end{itemize}
            \item $dirigidaPor(X, Y) \rightarrow director(Y)$:
            \begin{itemize}
                \item  \textit{director(``Alejandro Doria'')}
            \end{itemize}
            \item $actuaEn(X, Y) \rightarrow actor(Y)$:
            \begin{itemize}
                \item  \textit{actor(``China Zorrilla'')}
            \end{itemize}
            \item $actuaEn(X, Y) \land dirigidaPor(X, W) \rightarrow trabajaronJuntos(Y, W) $:
            \begin{itemize}
                \item  \textit{trabajaronJuntos(``Antonio Gasalla'', ``Alegandro Doria'')}
                \item  \textit{trabajaronJuntos(``China Zorrilla'', ``Alegandro Doria'')}
            \end{itemize}            
            \item $actor(X) \land actuaEn(X, Y) \rightarrow \exists Z interpretoA(X, Y, Z)$:
            \begin{itemize}
                \item  \textit{interpretoA(``Antonio Gasalla'', ``Esperando la Carroza'', $z_2$)}
            \end{itemize}
        \end{itemize}

        \item En la segunda iteración agregamos primero todos los átomos que obtuvimos en la iteración anterior y aplicamos sobre los átomos iniciales más los nuevos las TGDs. En este caso solo dos TGDs arrojan átomos nuevos:
        \begin{itemize}
            \item $dirigidaPor(X, Y) \rightarrow director(Y)$:
            \begin{itemize}
                \item \textit{director($z_1$)}
            \end{itemize}  
            \item $actor(X) \land actuaEn(X, Y) \rightarrow \exists Z interpretoA(X, Y, Z)$:
            \begin{itemize}
                \item \textit{interpretoA(``China Zorilla'', ``Esperando la Carroza'', $z_3$)}
            \end{itemize}            
        \end{itemize}        
    \end{itemize}

Para este ejemplo particular el resultado del \textit{chase}, es decir un modelo universal de $(D, \Sigma)$ es la siguiente instancia de base de datos:

\begin{equation}
    $$chase(D, $\Sigma$) = $D$ $\cup$ \{dirigidaPor(``Volver al Futuro'', $z_1$), director(``Alejandro Doria''), actor(``China Zorilla''), trabajaronJuntos(``Antonio Gasalla'', ``Alejandro Doria''), trabajaronJuntos(``China Zorilla'', ``Alejandro Doria''), interpretoA(``Esperando la Carroza'', ``Anotnio Gasalla'', $z_2$), director($z_1$), interpretoA(``Esperando la Carroza'', ``China Zorrilla'', $z_3$)\} $$
\end{equation} 
\end{exmp} 

\subsection{Datalog+/-, fragmento Guarded}

Esta fragmento consiste en una clase especial de TGDs que es tratable computacionalmente, siendo a la vez lo suficientemente expresiva como para modelar ontologías. Las consultas conjuntivas booleanas relativas a estas TGDs pueden ser evaluadas en una parte finita del \textit{chase}, que es de tamaño constante cuando las consulta y las TGDs están fijas. En base a este resultado, la complejidad de datos de evaluar una consulta conjuntiva booleana relativa a TGDs dentro del fragmento \textit{guarded}, resulta polinomial en el caso general y lineal para consultas atómicas.
Una TGD $\sigma$ está en el fragmento \textit{guarded} si solo si contiene un átomo en su cuerpo que contiene todas las variables cuantificadas universalmente en $\sigma$. El primer átomo más a la izquierda con estas característica se denomina la \textit{guarda} de  $\sigma$. Al resto de los átomos de $\sigma$ los llamamos \textit{átomos laterales} de $\sigma$.

\begin{exmp}\label{ejemplo_guarded}
    La TGD $actor(X) \land actuaEn(X, Y) \rightarrow \exists Z interpretoA(X, Y, Z)$ está en el fragmento \textit{guarded}, siendo \textit{actuaEn(X, Y)} la guarda y \textit{actor(X)} el átomo lateral. Mientras que la TGD $actuaEn(X, Y) \land dirigidaPor(X, W) \rightarrow trabajaronJuntos(Y, W)$ no está en el fragmento, dado que para ningún átomo del cuerpo sucede que este contenga a todas las variables que existen en el cuerpo. 
\end{exmp}
Notar que esta clase de TGDs asegura decibilidad. Como se muestra en \cite{cali}, agregar una sola TGD fuera del fragmento a un programa Datalog+/- puede quitar esta propiedad.
Sea entonces $R$ un esquema relacional, $D$ una base de datos para $R$, y $\Sigma$ un conjunto de TGDs en el fragmento guarded. El \textit{chase graph} para $D$ y $\Sigma$ es un grafo dirigido que consiste en los átomos de $chase(D,\Sigma)$ como el conjunto de nodos en los cuales habrá una flecha de \textbf{a} hacia \textbf{b} si solo si \textbf{b} es obtenido de \textbf{a} y posiblemente otros átomos por medio de una sola aplicación de alguna TGD $\sigma \in \Sigma$. Aquí marcamos a \textbf{a} como la guarda si solo si \textbf{a} es la guarda de $\sigma$. Consideramos ahora al \textit{guarded chase forest} como al subgrafo del \textit{chase graph} de $D$ y $\Sigma$ que consta de (i) todos los átomos del \textit{chase graph} como nodos y (ii) una flecha desde \textbf{a} hacia \textbf{b} si solo si \textbf{b} fue obtenido a partir de \textbf{a} y posiblemente otros átomos por medio de una sola aplicación de una TGD $\sigma \in \Sigma$ con \textbf{a} como guarda.

Definimos la profundidad \textit{guarded} de un átomo \textbf{a} en el \textit{guarded chase forest} para $D$ y $\Sigma$, denotada \textit{profundidad(\textbf{a})}, como la longitud del camino desde $D$ hasta \textbf{a} en el \textit{forest}. El \textit{guarded chase} de nivel menor o igual que $k$, denotado $g-chase^k(D, \Sigma)$, es el conjunto de todos los átomos en el \textit{guarded chase forest} de profundidad a lo sumo $k$.

\begin{exmp}\label{ejemplo_chase_forest}
    Sea $R$ un esquema relacional y sea $\Sigma$ un conjunto de TGDs para $R$ dado por:
    \begin{itemize}
        \item $\sigma_1 = r_1(X, Y) \land r_2(X) \rightarrow \exists Z r_3(Z, X, Y)$
        \item $\sigma_2 = r_3(X, Y, W) \rightarrow r_2(Y)$
        \item $\sigma_3 = r_2(Y) \land r_4(X, Y) \rightarrow r_1(Y, X)$
    \end{itemize}

Sea $D$ una base de datos para $R$ con $$D=\{r_4(a, b), r_1(a, b), r_2(a)\}$$
La siguiente figura muestra el \textit{chase graph} para $D$ y $\Sigma$. Para cada nodo en el grafo se muestra su \textit{nivel de derivación} en el chase, es decir el número de iteración en el algoritmo del chase en el que cada nodo fue agregándose al grafo.  
    
\begin{figure}[ht]
    \includegraphics[scale=0.5]{chase_graph}
    \centering
    \caption{Chase Graph}
    \label{fig:chase_graph}
\end{figure}

A modo de comparación, mostramos en la figura \ref{fig:guarded_forest} el \textit{guarded chase forest}, para mismo $D$ y $\Sigma$. Notar que el mismo es un sub-grafo del anterior y que las profundidades de los nodos son ahora siempre menores o iguales que sus respectivos niveles de \textit{derivación} en el  \textit{chase graph}. 

\begin{figure}[ht]
    \includegraphics[scale=0.5]{guarded_chase_forest}
    \centering
    \caption{Guarded Forest}
    \label{fig:guarded_forest}
\end{figure}

\end{exmp}

\subsubsection{Bounded guard-depth property para el fragmento Guarded}\label{guarded_forest_subsection}

Sea $R$ un esquema relacional y $\Sigma$ un conjunto de TGDs para $R$. Decimos que $\Sigma$ tiene la propiedad \textit{Bounded guard-depth property} solo si, para toda base de datos $D$ y para toda consulta conjuntiva booleana $Q$, para toda vez que exista un homomorfismo $\mu$ que mapea $Q$ en el $chase(D, \Sigma)$, entonces existe un homomorfiso $\delta(Q)$ tal que todos los ancestros de $\delta(Q)$ en el $chase graph$ para $D$ y $\Sigma$ están contenidos en el $g-chase^{\gamma_k}(D, \Sigma)$, donde $\gamma_k$ solo depende de $Q$ y $R$.

Tal como se muestra en \cite{JWS}, las TGDs del fragmento \textit{Guarded} poseen la propiedad anterior. En resumen, todos los átomos que se encuentran en la respuesta a una consulta conjuntiva se encuentran dentro del $g-chase^{(n + 1)\cdot\delta}$, con $\delta = (2\cdot\omega)^\omega\cdot2^{(2\omega)^{\omega\cdot|R|}}$, siendo $\omega$ la máxima aridad de algún predicado en $R$ y $n$ la cantidad de átomos en la consulta.

Esta profundidad en el \textit{guarded chase forest}, es independiente del tamaño de $D$, gracias a lo cual se puede afirmar que responder consultas en el fragmento \textit{Guarded} es $P-completo$ en la complejidad de datos.

\subsection{Datalog+/-, fragmento Lineal}

En el fragmento \textit{Lineal} de Datalog+/- las TGDs tienen un solo átomo en su cuerpo, es decir que tienen la forma $\forall X \forall  Y \Phi(X, Y) \rightarrow \exists Z \Psi(X,Z)$, siendo $\Phi(X,Y)$ un sólo átomo. Este fragmento esta estrictamente dentro del fragmento guarded, y aún perdiendo cierto poder expresivo con respecto al anterior, es lo suficientemente expresivo como para representar ontologías encodeadas en las \textit{Description Logics} de la familia \textit{Dl-Lite}. Además, tiene la ventaja de ser \textit{FO-rewritable} en la complejidad de datos.

\subsubsection{Bounded derivation-depth property}

Definimos ahora la \textit{bounded derivation-depth property} para un conjunto de TGDs, la cual es estrictamente más fuerte que la \textit{ bounded guard-depth property}, dado que la primera implica la segunda, pero no al revés. Informalmente, la \textit{bounded derivation-depth property} dice que para responder a una consulta conjuntiva no es necesario explorar más allá de una profundidad $k$ en el \textit{chase graph} (y no en el \textit{guarded chase forest} como en el fragmento anterior), cuyo tamaño solo depende de $Q$ y $R$.

\subsubsection{First-order rewritability}
Una clase de TGDs $\Sigma_t$ es reescribible en primer orden o \textit{first-order rewritable} si solo si para todo conjunto de TGDs en $\Sigma_t$ y para toda consulta conjuntiva booleana $Q$, existe una consulta de primer orden $Q_{\Sigma_t}$ tal que, para toda base de datos $D$, sucede que $D \cup \Sigma_t \models Q$ si solo si $D \models Q_{\Sigma_t}$. Dado que responder consultas de primer orden es un problema en $AC_0$ en la complejidad de datos \cite{Vardi}, también se encuentra en esta clase de problemas responder consultas bajo TGDs que sean reescribibles en primer orden. Teniendo en cuenta además que toda consulta de primer orden es reescribible a una consulta $Q^*$ de \textit{SQL}, esta propiedad nos indica que para el fragmento \textit{lineal} podemos hacer uso práctico de los motores de base de datos \textit{SQL} con todas las optimizaciones ya provistas por los mismos.

\begin{figure}[ht]
    \includegraphics[scale=0.3]{fo_rewrite.jpg}
    \centering
    \caption{First Order Rewrite}
    \label{fig:fo_rewrite}
\end{figure}

\begin{exmp}\label{ejemplo_rewrite}
Consideremos el siguiente conjunto $\Sigma_T$ de TGDs en el fragmento \textit{lineal} sobre un esquema $R$:
    \begin{itemize}
        \item $\sigma_1 = bonaerense(X) \rightarrow argentino(X)$
        \item $\sigma_2 = cordobes(X) \rightarrow argentino(X)$
        \item $\sigma_3 = londinense(X) \rightarrow ingl\acute{e}s(X)$
        \item $\sigma_4 = casado(X) \rightarrow \exists Z casadoCon(X, Z)$
    \end{itemize}
Si tenemos $Q(X) = argentino(X) \land casadoCon(X, Z)$ podemos reescribir esta consulta como una unión de consultas en las que para cualquier base de datos $D$ sobre $R$, y sin tener en cuenta $\Sigma_T$, la unión de los resultados de tales consultas será el mismo que el resultado de $Q(X)$ sobre $D$ y $\Sigma_T$. Es fácil ver que en este caso, la unión de las siguientes consultas es una reescritura válida $Q(X)$ $\Sigma_T$:

    \begin{itemize}
        \item $Q_1(X) = argentino(X) \land casadoCon(X, Z)$
        \item $Q_2(X) = bonaerense(X) \land casadoCon(X, Z)$
        \item $Q_3(X) = cordobes(X) \land casadoCon(X, Z)$
        \item $Q_4(X) = argentino(X) \land casado(X)$
        \item $Q_5(X) = bonaerense(X) \land casado(X)$
        \item $Q_6(X) = cordobes(X) \land casado(X)$
    \end{itemize}
\end{exmp}

Se han propuesto diversos algoritmos de reescritura [\cite{Kewen}, \cite{Gottlob}]. El objetivo es siempre conseguir una reescritura lo más chica posible, dado que esto permitirá un uso práctico real de los sistemas de base de datos \textit{SQL}. Cuando el resultado de la reescritura es demasiado grande, el uso práctico se diluye; dado que los motores \textit{SQL} van perdiendo su buena performance a medida que el tamaño de la consulta aumenta. 

\subsection{Negative Constraints}\label{ncs}
Una \textit{Negative Constraint} es una fórmula de primer orden de la forma $\forall X \Phi (X) \rightarrow \bot$, donde $\Phi(X)$ es una conjunción de átomos. Estas \textit{constraints} nos ayudan a expresar restricciones sobre las ontologías.

\begin{exmp}
Podemos decir que los predicados esNegativo y esPositivo representan dos clases que no tienen instancias en común de la siguiente forma: $$esPositivo(X) \land esNegativo(X) \rightarrow \bot$$
De manera similar podemos decir que ningún miembro de una clase pertenece a una relación:$$soltero(X) \land casadoCon(X, Y) \rightarrow \bot $$ Podemos inclusive expresar que dos relaciones son disjuntas: $$mayor(X,Y) \land menor(X, Y) \rightarrow \bot$$
\end{exmp}

Responder consultas en una base de datos bajo un conjunto de TGDs $\Sigma_T$ y un conjunto de restricciones $\Sigma_C$ puede realizarse sin agregar complejidad de la siguiente manera: para cada \textit{negative constraint} $\sigma = \Phi(X,Y) \rightarrow \bot \in \Sigma_C$ verificamos que se satisface en $D$ y $\Sigma_T$, lo cual se puede hacer chequeando que la consulta conjuntiva booleana $Q_\sigma = \Phi(X, Y)$ evalúe a Falso en $D$ y $\Sigma_T$. Escribimos $D \cup \Sigma_T \models \Sigma_C$ si solo si toda $\sigma \in \Sigma_C$ es falsa en $D$ y $\Sigma_T$. Esto nos lleva inmediatamente al siguiente resultado: decimos que una consulta conjuntiva booleana es verdadera en $D$, $\Sigma_T$ y $\Sigma_C$, y lo anotamos $D \cup \Sigma_T \cup  \Sigma_C \models Q$ si solo si (i) $D \cup \Sigma_T \models Q$ o (ii) $D \cup \Sigma_T \not\models \Sigma_C$.

\subsection{Equality-Generating Dependencies (EGDs) y Keys}
Las dependencias generadoras de igualdad o \textit{Equality-Generating Dependencies} también son importantes a la hora de representar ontologías. Estas son fórmulas de primer orden que generalizan dependencias funcionales y en particular claves.

Sin embargo, si bien es cierto que agregar \textit{negative constraints} es sencillo desde el punto de vista computacional, no sucede lo mismo con las EGDs: la interacción entre las TGDs y las EGDs puede tornar indecidible el problema de responder consultas\cite{Johnson}. Se puede comprobar que un conjunto fijo de EGDs y guarded TGDs pueden simular una maquina de Turing universal, con lo cual responder consultas es indecidible para tales dependencias. Por tal motivo, consideramos ahora una clase más restringida de EGDs, a las cuales llamamos \textit{claves no conflictivas}. Tal clase de EGDs muestra una interacción controlada con las TGDs (y NCs), de manera tal que no incrementan la complejidad de responder consultas, agregando al mismo tiempo suficiente poder expresivo para poder modelar ontologías.

Una \textit{dependencia generadora de igualdad} (o EGD) es una fórmula $\sigma$ de primer orden de la forma $\forall X \Phi(X) \rightarrow X_i = X_j$, donde $\Phi(X)$, el cual llamamos el cuerpo de $\sigma$, es una conjunción (no necesariamente guarded) de átomos, y $X_i$ y $X_j$ son variables en $X$. Llamamos a $X_i = X_j$ a la cabeza de $\sigma$. Tal $\sigma$ se satisface en una base de datos $D$ para $R$ si solo si, siempre que exista un homomorfismo $h$ tal que $h(\Phi(X) \subseteq D$, sucede que $h(X_i) = h(X_J)$. Se suelen omitir los cuantificadores universales en estas fórmulas, y consideramos solo conjuntos finitos de EGDs.

\begin{exmp}
La siguiente fórmula $\sigma$ es una EGD: $$r(X, Y_1) \land r(X,Y_2) \rightarrow Y_1 = Y_2.$$

La base de datos $D = \{r(a, b), r(c, d)\}$ satisface $\sigma$, dado que todo homomorfismo h que mapee el cuerpo de $\sigma$ a átomos de $D$ es tal que $h(Y_1) = h(Y_2)$. Por el contrario, la base de datos $D = \{r(a, b), r(a, d)\}$ no satisface $\sigma$.

\end{exmp}

Una EGD $\sigma$ sobre $R$ de la forma $\Phi(X) \rightarrow X_i = X_j$ es \textit{aplicable} a una base de datos $D$ si solo si existe un homorfismo $\eta : \Phi(X) \rightarrow D$ tal que $\eta(X_i)$ y $\eta(X_j)$ son distintos y no son ambos constantes. Si $\eta(X_i)$ y $\eta(X_j)$ son constantes distintas en $\Delta$, entonces hay una violación de $\sigma$, y el chase falla. Caso contrario, el resultado de aplicar $\sigma$ a $D$ es la base de datos $h(D)$ que se obtiene a partir de $D$ al reemplazar toda ocurrencia de algún elemento no constante $e \in \{\eta(X_i), \eta(X_j)\}$ en $D$ para el otro elemento $e\prime$ (si $e$ y $e\prime$ son los dos nulos, entonces $e$ precede a $e\prime$ en orden lexicográfico.)

El chase para una base de datos $D$ y un conjunto $\Sigma_T$ de TGDs más un conjunto $\Sigma_E$ de $EGDs$, el cual llamamos \textit{full chase} y denotamos $chase(D, \Sigma_T \cup \Sigma_E)$, se computa de manera iterativa por medio de aplicar todas las EGDs que sean aplicables entre cada aplicación de cada TGD como se describió previamente.

\begin{exmp}
Consideremos el siguiente conjunto de TGDs y EGDs $\Sigma = \{\sigma_1, \sigma_2, \sigma_3\}$:

\begin{itemize}
    \item [$\sigma_1:$] $p(X) \rightarrow \exists Z s(X, Z)$
    \item [$\sigma_2:$] $s(X, Y), r(X)  \rightarrow X = Y$
    \item [$\sigma_3:$] $s(X, Y), s(X, Z) \rightarrow Y = Z$
\end{itemize}

Sea $D$ la base de datos $\{p(a), r(a), s(a, b)\}$. En el cómputo de $chase(D, \Sigma)$, primero aplicamos $\sigma_1$ y agregamos el átomo $s(a, z_1)$, donde $z_1$ es un nulo. Entonces, al aplicar $\sigma_2$ sobre $r(a)$ y $s(a, z_1)$ transformamos $s(a, z_1)$ en $s(a, a)$. Ahora $\sigma_3$ resulta aplicable sobre $s(a, a)$ y $s(a, b)$, pero al intentar igualar $a = b$ el \textit{chase} falla, pues hay una violación, dado que $a$ y $b$ son constantes distintas en $\Delta$.
\end{exmp}

\subsubsection{Separabilidad}
Sea $R$ un esquema relacional, y sean $\Sigma_T$ y $\Sigma_E$ dos conjuntos de \textit{TGDs} y \textit{EGDs} sobre $R$, respectivamente. Entonces, $\Sigma_E$ es separable de $\Sigma_T$ si solo si para toda base de datos $D$ sobre $R$, se cumplen las siguientes condiciones: 
\begin{itemize}
    \item  Si hay una violación de una \textit{EGD} $\sigma \in \Sigma_E$ en $chase(D, \Sigma_T \cup \Sigma_E)$, entonces hay también una violación de $\sigma$ en $D$.
    \item Si no hay violación de ninguna \textit{EGD} $\sigma \in \Sigma_E$ entonces para toda consulta $Q$, sucede que $chase(D, \Sigma_T \cup \Sigma_E) \models Q$ si solo si $chase(D, \Sigma_T) \models Q$.
\end{itemize}

Esto implica que agregar \textit{EGDs} separables a un conjunto de \textit{TGDs} no incrementa la complejidad de contestar consultas, tanto en el caso \textit{lineal} como el el \textit{guarded}. Lo anterior se puede afirmar gracias a que es suficiente evaluar si cada EGD se satisface en D, y si esto ocurre es posible construir el \textit{chase} sin necesidad de aplicar el algoritmo del \textit{full chase}, pues ambos arrojarán el mismo resultado.

Sea q un predicado sobre R y p1,p2,..pn posiciones en p, una clave K, denotada como K ={q[p1], q[p2], ....,q[n]},.... 

\subsubsection{Claves}
Dado un predicado relacional $p$ sobre un esquema relacional $R$ una clave $K$ sobre $p$ es un conjunto de posiciones para el cual sucede que para toda base de datos $D$ sobre $R$ no pueden existir dos \textit{hechos} en $D$ para $p$ tales que los dos hechos tengan los mismos valores en todas las posiciones de $K$ pero distintos valores en posiciones que no estén incluidas en $K$. Sean entonces $p_1, p_2,...p_n$ el conjunto de posiciones y sea $q$ el predicado sobre el cual se quiere definir una clave $k$. Denotamos esta clave por medio de $k=\{q[p1], q[p2], ...,q[p_n]\}$.

\begin{exmp}
Sea $p$ el predicado binario \textit{padreDe} sobre un esquema relacional $R$, donde la primer posición indica el DNI de una persona y la segunda posición el DNI de su padre. Sea $k\{p[1]\}$ una clave definida sobre \textit{padreDe}. Esto indica que no pueden existir dos átomos en $D$ con igual DNI en la primera posición y distinto DNI en la segunda posición, es decir que ninguna persona puede tener dos padres diferentes.
\end{exmp}

Podemos definir una clave a partir de un conjunto de EGDs.
\begin{exmp}
Sea $p$ un predicado ternario sobre un esquema relacional $R$. Sea $k[1]$ una clave para $p$. Podemos expresar esta clave por medio de dos EGDs:
\begin{itemize}
    \item $p(X, Y_1, Z_1) \land p(X, Y_2, Z_2) \rightarrow Y_1 = Y_2$.
    \item $p(X, Y_1, Z_1) \land p(X, Y_2, Z_2) \rightarrow Z_1 = Z_2$.
\end{itemize}
\end{exmp}


\subsubsection{Claves no conflictivas}\label{claves_no_conflictivas}
Sea $K$ una clave, y sea $\sigma$ una TGD de la forma $\Phi(X, Y) \rightarrow \exists Z r(X, Z)$. Decimos que $K$ es no conflictiva (NC) con $\sigma$ si se cumple alguna de las siguientes condiciones:
\begin{itemize}
    \item El predicado relacional sobre el cual $K$ está definido es diferente de $r$.
    \item Las posiciones de $K$ en $r$ no son un subconjunto propio de las posiciones de $X$ en $r$ en la cabeza de $\sigma$, y toda variable en $Z$ aparece una sola vez en la cabeza de $\sigma$. 
\end{itemize}

Decimos que $K$ es no conflictiva con un conjunto de TGDs $\Sigma_T$ si solo si $k$ es no conflictiva con toda $\sigma \in \Sigma_T$. Un conjunto de claves $\Sigma_K$ es no conflictivo con $\Sigma_T$ si solo si todas clave $k \in \Sigma_K$ es no conflictiva con $\Sigma_T$.

\begin{exmp}
Consideremos las siguientes claves $K_1, K_2, K_3, K_4$ definidas por los siguientes conjuntos de posiciones para el predicado $r$: $K_1=\{r[3]\}, K_2=\{r[2], r[3]\}, K_3=\{r[1]\},  K_4=\{r[1], r[2]\}$, y la TGD $\sigma = p(X, Y) \rightarrow \exists Z r(Z, X, Y)$. Teniendo en cuenta entonces que la cabeza de $\sigma$ es $r$, y el conjunto de posiciones en $r$ con variables cuantificada universalmente es $H = \{r[2], r[3]\}$, resulta que $K_1$ es la única clave definida por un conjunto de posiciones que es subconjunto propio de $H$. Por lo tanto salvo $K_1$, todas las claves son no conflictivas con $\sigma$.
\end{exmp}

Tal como se muestra en \cite{JWS}, la propiedad de no conflictivdad entre un conjunto de claves y un conjunto de TGDs, implica su separabilidad. La principal idea detrás de la prueba se describe a continuación. La condición de no conflictividad entre una clave $K$ y una TGD $\sigma$ asegura que o bien (a) la aplicación de $\sigma$ en el \textit{chase} genera un átomo con un nuevo nulo en una posición de $K$, y entonces este nuevo átomo no viola K; o bien (b) las posiciones cuantificadas universalmente en la cabeza de $\sigma$ coinciden con las posiciones de la clave $K$, con lo cual cualquier átomo nuevo generado a partir de $\sigma$ debe tener nulos frescos en todas las posiciones salvo las de la clave, no produciéndose una violación en este caso tampoco. Como todos los nuevos nulos son distintos entre sí, el \textit{chase} es homomórficamente equivalente al \textit{TGD full chase}.

Concluímos entonces esta sección afirmando que en el caso NC, las claves no incrementan la complejidad-datos de contestar consultas bajo TGDs y constraints, tanto para el fragmento \textit{guarded} como para el \textit{lineal}.

\section{Manejo de inconsistencia}
En lo que sigue describiremos distintas semánticas para \textit{query answering} tolerante a la inconsistencia. Todas ellas se basan en la noción de \textit{data base repair}. El objetivo es, a través de las consultas, obtener siempre información consistente; intentando a la vez alcanzar un buen equilibrio entre el poder expresivo de las semánticas y la complejidad computacional que estas requieren. 
\subsubsection{Inconsistencia en Datalog +/-}

Asumiremos en este trabajo que las \textit{TGDs, NCs y Keys} son correctas; es decir, capturan correctamente la semántica del dominio. Esta suposición implica que el conjunto $\Sigma$  dado por $\Sigma_T \cup \Sigma_N \cup \Sigma_K$  es siempre satisfacible; es decir que la aplicación de las TGDs no generan inconsistencias. En este enfoque los conflictos se generan a partir de los datos: la instancia de base de datos es la parte que debe ser \textit{reparada} o \textit{modificada} para restaurar la consistencia pudiendo así cumplir con las restricciones que impone el conjunto dado por $\Sigma_N \cup \Sigma_K$ . Cabe mencionar que esta no es la única opción. Muchos trabajos actuales se enfocan en otras posibilidades (\cite{Huang}, \cite{Hitzler}, \cite{Parsia}, \cite{Haasa}).

\subsubsection{Database repairs}

Mencionamos anteriormente que nuestro objetivo es obtener información consistente, aún conviviendo en ambientes con datos inconsistentes. ¿Pero como podemos obtener información consistente a partir de una base de datos que no lo es?. La principal herramienta que utilizaremos para alcanzar este objetivo es la noción de \textit{data base repair.} Dada una base de datos $D$ que contradice un conjunto de restricciones de integridad y de claves obtendremos un subconjunto de $D$ que no contradice estas restricciones pero que difiere de $D$ \textit{minimalmente}. Formalmente decimos que un \textit{repair} para ($D$, $\Sigma$) es una base de datos $D\prime$ tal que:
\begin{itemize}
    \item $D\prime \subseteq D$
    \item $mods(D\prime, \Sigma) \neq \varnothing $
    \item $ \nexists D\prime \prime$ tal que $D\prime\prime \subset D\prime$ y $mods(D\prime \prime, \Sigma) \neq \varnothing$
\end{itemize}

\begin{exmp}\label{ejemplo_ar}
Sea $R$ un esquema relacional y sea $\Sigma_T$ un conjunto de TGDs para $R$ dado por:
    \begin{itemize}
        \item $\sigma_1 = amigos(X, Y) \rightarrow tieneAmigos(X)$
        \item $\sigma_2 = amigos(X, Y) \rightarrow tieneAmigos(Y)$
        \item $\sigma_3 = amigos(X, Y) \land tienePiojos(X) \rightarrow tienePiojos(Y)$
    \end{itemize}
Sea $\Sigma_n$ el conjunto de restricciones dado por una única restricción
    \begin{itemize}
        \item $\sigma_n = pelado(X) \land tienePiojos(X) \rightarrow \bot$
    \end{itemize}
Sea $D$ una base de datos para $R$ dada por los siguiente hechos:
    \begin{itemize}
        \item tienePiojos('Federico')
        \item amigos('Federico', 'Miguel')
        \item amigos('Miguel', 'Pablo')
        \item esPelado('Pablo')
    \end{itemize}
Al aplicar el algoritmo del \textit{chase} sobre $D$ y $\Sigma_T$ obtenemos que:
\begin{gather*}
    chase(D, \Sigma_T) = D \cup \{tieneAmigos('Federico'), tieneAmigos('Miguel'),\\ tieneAmigos('Pablo'), tienePiojos('Miguel'), tienePiojos('Pablo')\}
\end{gather*}

Vemos entonces que en $chase(D, \Sigma_T)$ hay una violación de $sigma_n$, pues resulta que este contiene simultáneamente los átomos $esPelado('Pablo')$ y $tienePiojos('Pablo')$.
El conjunto de \textit{repairs} para $(D, \Sigma)$ está dado entonces por:
    \begin{itemize}
        \item $r_1 = \{ tienePiojos('Federico'), amigos('Federico', 'Miguel'), amigos('Miguel', 'Pablo')\}$
        \item $r_2 = \{ tienePiojos('Federico'), amigos('Federico', 'Miguel'), esPelado('Pablo')\}$
        \item $r_3 = \{ tienePiojos('Federico'), amigos('Miguel', 'Pablo'), esPelado('Pablo')\}$
        \item $r_4 = \{ amigos('Federico', 'Miguel'), amigos('Miguel', 'Pablo'), esPelado('Pablo')\}$
    \end{itemize}
    
Notar que en este caso cada uno de los \textit{repairs} está dado por incluír en el \textit{repair} cualquier subconjunto de tres átomos de entre los cuatro átomos de $D$. Al decir que Federico es amigo de Miguel, y que Miguel es amigo de Pablo, y al decir que los amigos se contagian los piojos, tiene que ser que Federico le contagio los piojos a Miguel y este se los contagió a Pablo. Pero esto no puede ser porque Pablo es pelado. Observar entonces que quitando cualquier átomo de $D$, obtenemos un subconjunto maximal consistente.
    
\end{exmp}

\subsubsection{Semántica AR}
La semántica AR, es la más aceptada para \textit{query answering} en ontologías potencialmente inconsistentes. Dada una base de conocimiento $(D, \Sigma)$ y una consulta conjuntiva $Q$, decimos que $(D, \Sigma) \models_{AR} Q$ si solo si $(R, \Sigma) \models Q$ para todo R \textit{repair} de $(D, \Sigma)$.

En el ejemplo anterior, si tomamos $Q() = tieneAmigos('Miguel')$, resulta que $(D, \Sigma) \models_{AR} Q$. En cambio, si consideramos la consulta $Q() = tieneAmigos('Pablo')$ resulta que $(D, \Sigma)\not\models_{AR} Q$.

La semántica AR definida arriba coincide con la semántica tolerante a la inconsistencia para Lógicas de Descripción presentada en \cite{Lembo}. Aunque esta semántica puede ser considerada en cierto sentido la elección natural para el objetivo semántico que estamos buscando, tiene la desventaja de ser dependiente de la forma sintáctica de la base de conocimiento. Supongamos que la base de conocimiento $KB\prime = (D\prime, \Sigma)$ difiere de la base de conocimiento $KB = (D, \Sigma)$ simplemente porque $D\prime$ incluye átomos que se pueden inferir a partir de $\Sigma$ y un subconjunto consistente de $D$. En este caso $KB$ y $KB\prime$ son lógicamente equivalentes, y cabe esperar por lo tanto que sus \textit{repairs} coincidan y que las respuestas a toda consulta sobre $KB$ y $KB\prime$ coincidan bajo toda semántica. Sin embargo esto no sucede con la semántica \textit{AR}. 


\begin{exmp}\label{ejemplo_ar_2}
Considerando $D$ y $\Sigma$ del ejemplo anterior, definamos ahora la base de datos $D\prime$ dada por $D \cup \{tieneAmigos('Pablo')\}$. Es claro que el nuevo átomo introducido se puede inferir lógicamente de $D$ y $\Sigma$, notar de hecho que el mismo se encuentra en el chase de aquel ejemplo. Si consideramos ahora los \textit{repairs} para $D\prime$ y $\Sigma$ obtenemos
    \begin{itemize}
        \item $r\prime_1 = r_1 \cup \{tieneAmigos('Pablo')\}$
        \item $r\prime_2 = r_2 \cup \{tieneAmigos('Pablo')\}$
        \item $r\prime_3 = r_3 \cup \{tieneAmigos('Pablo')\}$
        \item $r\prime_4 = r_4 \cup \{tieneAmigos('Pablo')\}$
    \end{itemize}

Con lo cual resulta que $(D\prime, \Sigma)\models_{AR} tieneAmigos('Pablo')$, resultado opuesto para la $KB$ del ejemplo anterior.
\end{exmp}

\subsubsection{Semántica CAR}
Dependiendo del escenario particular en el que se quiera resolver este tipo de inconsistencias, el comportamiento anterior podría ser considerado incorrecto. Esto motivó la definición de una nueva semántica que no presenta esta característica. De acuerdo con esta semántica, llamada \textit{Closed ABox Repair}, los \textit{repairs} toman en cuenta no solo los hechos explícitamente incluídos en $D$, sino también aquellos hechos que se pueden inferir junto con $\Sigma$ y al menos un subconjunto de $D$ que sea consistente.
Para formalizar la idea anterior, es necesario dar primero las siguientes definiciones. Dada una base de conocimiento $K = (D, \Sigma)$, denotamos por medio de $HB(K)$ a la \textit{Herbrand Base} de $K$, es decir el conjunto de hechos que se pueden construir sobre el alfabeto de de $\Gamma_K$. Definimos después las consecuencias lógicas de $K$ como el conjunto $clc(K) = \{\alpha | \alpha \in HB(K) \land \exists S \subseteq D$ tal que $Mods(S, \Sigma) \neq  \varnothing \land (S, \Sigma) \models \alpha \}$. Podemos ahora dar la siguiente definición de \textit{Closed ABox Repair}.

Sea $K = (D, \Sigma)$ una base de conocimiento en Datalog+/-. Un \textit{Car Repair} de $K$ es un conjunto $D\prime$ de hechos tales que:
    \begin{enumerate}
        \item $D\prime \subseteq clc(K)$
        \item $mods(D\prime, \Sigma) \neq \varnothing$
        \item $\nexists D\prime\prime$ tal que $mods(D\prime\prime, \Sigma) \neq \varnothing$ y :
        \begin{itemize}
            \item $D\prime\prime \cap D \supset D\prime \cap D$ o,
            \item $D\prime\prime \cap D = D\prime \cap D \land D\prime\prime \supset D\prime$   
        \end{itemize}
    \end{enumerate}

Denotamos por medio de $CAR-Rep(D, \Sigma)$ al conjunto de todos los \textit{Car Repairs} para $K$.
Intuitavemnte, un \textit{CAR-repair} es un subconjunto de \textit{clc(K)} consistente con $\Sigma$ que preserva máximamente al conjunto de hechos $D$. En particular, la condición 3 dice que preferimos a $D\prime$ por encima de cualquier otro $D_R \subseteq clc(K)$ consistente con $\Sigma$ tal que $D_R \cap D \subset D\prime \cap D$ (es decir que $D_R$ mantiene un subconjunto más pequeño de $D$ con respecto a $D\prime$). Entonces, entre todos aquellos subconjuntos $D_R$ que tengan la misma intersección con $D$, preferimos a aquellos que contengan la mayor cantidad de hechos en \textit{clc(K)} posibles.
Dada $KB = (D, \Sigma)$ y una consulta conjuntiva $Q$, decimos que $KB \models_{CAR} Q$ si solo si $(R, \Sigma) \models Q$ para cada $R \in CAR-Rep(D, \Sigma)$.

\begin{exmp}\label{ejemplo_car_repairs}
Consideremos las bases de conocimiento presentadas en \ref{ejemplo_ar} y en el \ref{ejemplo_ar_2} y veamos que en este caso el conjunto de \textit{CAR-repairs} es el mismo para las dos bases. Para eso construímos primero el conjunto \textit{clc(K)}. Es fácil ver que para ambos ejemplos este conjunto esta dado por clc(K) = \{amigos('Federico', 'Miguel'), amigos('Miguel', 'Pablo'), tieneAmigos('Federico'), tieneAmigos('Miguel'), tieneAmigos('Pablo'), tienePiojos('Federico'), tienePiojos('Miguel'), tienePiojos('Pablo'), esPelado('Pablo')\} y que en ambos casos el conjunto de \textit{CAR-repairs} está dado por:
        \begin{itemize}
            \item \{amigos('Federico', 'Miguel'), amigos('Miguel', 'Pablo'), tieneAmigos('Federico'), tieneAmigos('Miguel'), tieneAmigos('Pablo'), tienePiojos('Federico'), tienePiojos('Miguel'), tienePiojos('Pablo')\}
            \item \{amigos('Federico', 'Miguel'), amigos('Miguel', 'Pablo'), tieneAmigos('Federico'), tieneAmigos('Miguel'), tieneAmigos('Pablo'),  esPelado('Pablo')\}
            \item \{amigos('Federico', 'Miguel'), tieneAmigos('Federico'), tieneAmigos('Miguel'), tieneAmigos('Pablo'), tienePiojos('Federico'), tienePiojos('Miguel'),  esPelado('Pablo')\}
           \item \{amigos('Miguel', 'Pablo'), tieneAmigos('Federico'), tieneAmigos('Miguel'), tieneAmigos('Pablo'), tienePiojos('Federico'), esPelado('Pablo')\}
        \end{itemize}
Notar que dado que el conjunto de \textit{CAR-repairs} es el mismo para ambas bases de conocimiento, las respuestas serán siempre las mismas para toda consulta $Q$ bajo esta semántica. En particular teniendo en cuenta $D$ y $\Sigma$ del ejemplo \ref{ejemplo_ar} tenemos que $$(D, \Sigma)\models_{CAR} tieneAmigos('Pablo'),$$ y lo mismo ocurre para $D\prime$ y $\Sigma$ del ejemplo \ref{ejemplo_ar_2}.
\end{exmp}

\subsubsection{Semánticas de intersección}
En general, responder consultas es intratable tanto para la semántica \textit{CAR} como \textit{AR}. Dado que esto supone un obstáculo en su uso práctico, se propusieron aproximaciones de estas semánticas, para las cuales se ha demostrado que responder consultas conjuntivas es polinomial en las lógicas de descripción \textit{DL-Lite}. En ambos casos, la aproximación consiste en tomar como único \textit{repair} la intersección de los \textit{AR-repairs} y de los \textit{CAR-repairs} respectivamente. Esta idea se corresponde con el enfoque \textit{WIDTIO (When you are in doubt throw it out)}, provenitente del área de revisión de creencias [\cite{Eiter},\cite{Winslett}].

\subsubsection{Semántica IAR}
Sea $KB = (D, \Sigma)$ una base de conocimiento, y sea $Q$ una consulta conjuntiva. Decimos que $KB \models_{IAR}$ si solo si $(\cap_{R \in AR-Rep(D, \Sigma)}, \Sigma)\models Q$ 

\begin{exmp}\label{ejemplo_iar}
Consideremos $(D, \Sigma)$ y el conjunto de \textit{AR-repairs} del ejemplo \ref{ejemplo_ar}. La intersección de aquellos \textit{repairs} es el conjunto vacío. Por lo tanto, para toda consulta $Q$ resulta que $(D, \Sigma)\not\models_{IAR} Q$. Si consideramos en cambio $(D\prime, \Sigma)$ del ejemplo \ref{ejemplo_ar_2} y consideramos la consulta $Q() = tieneAmigos('Pablo')$, resulta que $(D, \Sigma)\models_{IAR} Q$. Notar entonces que la semántica \textit{IAR} sufre la misma desventaja que la semántica \textit{AR}, pues también es dependiente de la forma sintáctica de la base de conocimiento.
\end{exmp}

\subsubsection{Semántica ICAR}
De manera análoga a la definición de la semántica \textit{IAR} definimos la semántiuca \textit{ICAR}. Sea $KB = (D, \Sigma)$ una base de conocimiento, y sea $Q$ una consulta conjuntiva. Decimos que $KB \models_{ICAR}$ si solo si $(\cap_{R \in CAR-Rep(D, \Sigma)}, \Sigma)\models Q$

\begin{exmp}
Al igual que la semántica \textit{CAR}, la semántica \textit{ICAR} tiene la ventaja de no ser dependiente de la forma sintáctica de la KB. Teniendo en cuenta lo comentado en el ejemplo \ref{ejemplo_car_repairs}, es fácil ver que tanto para la base de conocimiento presentada en el ejemplo \ref{ejemplo_ar} como para la presentada en el ejemplo \ref{ejemplo_ar_2}, la intersección de los \textit{CAR-repairs} coincide. Esta intersección está dada por el conjunto \{tieneAmigos('Federico'), tieneAmigos('Miguel'), tieneAmigos('Pablo')\}. Podemos ejemplificar entonces diciendo que:
\begin{itemize}
    \item $(D, \Sigma) \models_{ICAR} tieneAmigos('Pablo')$.
    \item $(D, \Sigma) \not\models_{ICAR} sonAmigos('Miguel','Pablo')$.
\end{itemize}

\end{exmp}

\subsubsection{Semántica ICR}
Sea $Cn(D,\Sigma)$ la clausura lógica de $D$ y $\Sigma$. Sea $KB$ una base de conocimiento $(D, \Sigma)$, y sea $Q$ una consulta conjuntiva. Decimos que $KB \models_{ICR} Q $ si solo si $(\cap_{R \in Rep(KB)}, Cn(R, \Sigma))\models Q$. Veremos a continuación que esta semántica es una \textit{aproximación \textit{sana}} de \textit{AR} e \textit{ICAR}, y que además es una aproximación \textit{completa} de \textit{IAR}.

\begin{exmp}
Consideremos $D$ y $\Sigma$ del ejemplo \ref{ejemplo_ar}. Tenemos que calcular las clausuras lógicas de los cuatro \textit{repairs} de ese mismo ejemplo.
    \begin{itemize}
        \item $Cn(r_1)$ = \{ tienePiojos('Federico'), amigos('Federico', 'Miguel'), amigos('Miguel', 'Pablo'), tienePiojos('Miguel'), tienePiojos('Pablo'), tieneAmigos('Federico'), tieneAmigos('Miguel'), tieneAmigos('Pablo')\}
        \item $Cn(r_2)$ = \{ tienePiojos('Federico'), amigos('Federico', 'Miguel'), esPelado('Pablo'), tieneAmigos('Federico'), tieneAmigos('Miguel'), tienePiojos('Miguel')\}
        \item $Cn(r_3)$ = \{ tienePiojos('Federico'), amigos('Miguel', 'Pablo'), esPelado('Pablo'), tieneAmigos('Miguel'), tieneAmigos('Pablo')\}
        \item $Cn(r_4)$ = \{ amigos('Federico', 'Miguel'), amigos('Miguel', 'Pablo'), esPelado('Pablo'), tieneAmigos('Federico'), tieneAmigos('Miguel'), tieneAmigos('Pablo') \}
    \end{itemize}
La intersección de estos conjuntos esta dada por \{ tieneAmigos('Federico'), tieneAmigos('Miguel') \}. Podemos decir entonces que $(D, \Sigma) \models_{ICR} tieneAmigos('Federico') \land tieneAmigos('Miguel')$.
\end{exmp}
Notemos que tal como se comentó en el ejemplo \ref{ejemplo_iar}, para mismo $D$ y $\Sigma$, la intersección de los \textit{repairs} fue el conjunto vacío. Es decir que al menos en este caso la semántica \textit{IAR} fue más restrictiva que la semántica \textit{ICR}. Veremos en la próxima sección que en verdad esto se cumple para todo $D$ y todo $\Sigma$.

\subsection{Aproximaciones sanas y completas}
Dadas dos semánticas \textit{A} y \textit{B}, decimos que la semántica \textit{A} es \textit{sana} con respecto a la semántica \textit{B} si solo si para toda consulta $Q$ resulta que si Q es verdadera bajo la semántica \textit{A} también lo es bajo la semántica \textit{B}. Por el contrario, \textit{A} es \textit{completa} con respecto a \textit{B} si solo si para toda consulta $Q$ resulta que si $Q$ es verdadera bajo \textit{B} también lo es bajo \textit{A}. De esto se desprende que si \textit{A} es \textit{sana} respecto de \textit{B} entonces \textit{B} es \textit{completa} respecto de \textit{A}.

Veamos ahora como se aproximan entre sí las semánticas que hemos mencionado. En la siguiente figura hay una flecha que parte desde la semántica \textit{A} hacia la semántica \textit{B} si solo si la semántica \textit{A} es una aproximación sana de la semántica \textit{B}.


\begin{figure}[ht]
    \includegraphics[scale=0.3]{SemanticasOrdenadas.png}
    \centering
    \caption{Aproximaciones entre las semánticas}
    \label{fig:aproximaciones}
\end{figure}

Tal como se muestra en el gráfico, \textit{IAR} es la semántica más restrictiva, siendo esta una aproximación \textit{sana} de \textit{ICR}, y siendo esta última una aproximación \textit{sana} de \textit{AR} e \textit{ICAR}, aunque estas dos no se aproximan entre sí. Por otro lado \textit{AR} e \textit{ICAR} son aproximaciones \textit{sanas} de \textit{CAR}, la menos restrictiva de todas las semánticas. 

\chapter{Resultados Formales}
\section{Algoritmo RepairsFinder}\label{repairs_finder_section}
Presentamos ahora un algoritmo que dada una base de conocimientos $(D, \Sigma)$, con $\Sigma = \Sigma_T \cup \Sigma_N$, retorna todos sus \textit{repairs}, es decir todos los subconjuntos de $D$ maximales consistentes con respecto a $\Sigma$. Nuestro objetivo es recortar el espacio de búsqueda y evitar a la vez la mayor cantidad de consultas a la base de conocimiento. Dada una base de datos $D$ con $n$ \textit{hechos}, la cantidad de posibles subconjuntos para esa base de datos es $2^n$. Podríamos de manera \textit{naive} considerar la totalidad de los subconjuntos y para cada uno de ellos evaluar consistencia y maximalidad. Sin embargo, sabemos que es necesario organizar la búsqueda de los \textit{repairs} de manera eficiente, dada la gran cantidad de subconjuntos que necesitaríamos explorar de otro modo. Tengamos en cuenta además, que para evaluar si un subconjunto $s$ es consistente, necesitamos evaluar cada una de las \textit{Negative Constraints} en $\Sigma_N$ contra $s$. Tal como se detalló en la sección \ref{ncs}, para evaluar una $NC: \phi(x, y) \rightarrow \bot$, podemos evalular la consulta $Q(x, y) = \phi(x, y)$ sobre $(s, \Sigma_T)$ y si la respuesta es distinta al conjunto vacío entonces decimos que hay una violación de tal \textit{NC} y que por lo tanto $s$ no es consistente. Pero como ya mencionamos, queremos minimizar estas consultas lo más posible.

El algoritmo \textit{RepairsFinder} intenta minimizar el espacio de búsqueda con una estrategia \textit{BottomUp} y \textit{TopDown} en simultáneo, descartando todos los subconjuntos de $D$ que sean subconjunto de algún \textit{repair} ya encontrado o superconjunto de algún subconjunto minimal inconsistente, lo que llamaremos de ahora en más \textit{culprit}. 

Teniendo en cuenta que si etiquetamos numéricamente todos los \textit{hechos} en $D$ y mantenemos los subconjuntos ordenados a lo largo de todo el algoritmo, verificar si un subconjunto es subconjunto de otro, tiene un costo lineal en el tamaño del subconjunto más chico. Por tal motivo, verificar inclusión de conjuntos no es significativamente menos eficiente que consultar la \textit{KB} desde el punto de vista computacional. 

\begin{figure}
\begin{algorithm}[H]
\SetAlgoLined
    \KwIn{$(D, \Sigma)$ }
    \KwOut{Repairs para $(D, \Sigma)$ }
$nTop \gets \sharp(D)$\;
$nBottom \gets 1$\;
$top \gets subConjuntosDeKElementos(D, nTop)$\;
$bottom \gets subConjuntosDeKElementos(D, nBottom)$\;
$culprits \gets \emptyset$\;
$repairsChicos \gets \emptyset$\;
$repairsGrandes \gets \emptyset$\;

$InicializarBottom()$\;


 \While{top $\neq \emptyset$ {\bf and} bottom $\neq \emptyset$ {\bf and} nTop $>$ nBottom   }{
            $IterarTop()$\;			
			$IterarBottom()$\;
}
\If{nBottom == nTop {\bf and} $top \neq \emptyset$ }
{
$AgregarConsistentesEnTopARepairs()$\;
}
\Return{$repairsChicos \cup repairsGrandes$}
 \caption{RepairsFinder}
\end{algorithm}
\end{figure}

\begin{figure}
\begin{algorithm}[H]
\SetAlgoLined

\For{$b \in bottom$}{
$b.consistente \gets chequearConsistencia(b, \Sigma)$\;
\lIf{$\neg b.consitente$}{
$culprits.agregar(b)$}
}
$bottom \gets bottom.filtrarPor(b \rightarrow b.consistente )$

 \caption{InicializarBottom}
\end{algorithm}



\begin{algorithm}[H]
\SetAlgoLined
$AgregarConsistentesEnTopARepairs()$\;
$top \gets subConjuntosDeKElementos(D, nTop - 1).filtrarPor(t \rightarrow repairsGrandes.ningunoCumple(rg \rightarrow t \subset rg) ))$\;	
$nTop--$\;		
\caption{IterarTop}
 
 
\end{algorithm}
\end{figure}
\begin{figure}
\begin{algorithm}[H]
\SetAlgoLined
\For{$t \in top$}{
     \lIf{$culprits.algunoCumple(c \rightarrow c \subset t)$}{$t.consistente \gets false$}
     \Else{$t.consistente \gets chequearConsistencia(t, \Sigma)$\;
        \lIf{t.consistente}{repairsGrandes.agregar(t)}
        }
}
\caption{AgregarConsistentesEnTopARepairs}
 
 
\end{algorithm}

\begin{algorithm}[H]
\SetAlgoLined


 $proximoBottom \gets subConjuntosDeKElementos(D, nBottom + 1).filtrarPor(pb \rightarrow culprits.ningunoCumple(c \rightarrow c \subset pb))$\;
\For{$pb \in proximoBottom$}{
     \lIf{$repairsGrandes.algunoCumple(rg \rightarrow pb \subset rg)$}{$pb.consistente \gets true$}
     \Else{$pb.consistente \gets chequearConsistencia(pb, \Sigma)$\;
        \lIf{$\neg pb.consistente$}{$culprits.agregar(pb)$}
        }
}

\For{$b \in bottom$}{
     \If{$proximoBottom.filtrarPor(pb \rightarrow b \subset pb).todosCumplen(pb \rightarrow \neg pb.consistente) $}
        {$repairsChicos.agregar(b)$}
}
$bottom \gets proximoBottom.filtrarPor(b \rightarrow b.consistente)$\;
$nBottom++$\;
 \caption{IterarBottom}

\end{algorithm}
\end{figure}

\subsection{Entendiendo RepairsFinder}

En el algoritmo \textit{RepairsFinder} se define el siguiente conjunto de variables:
\begin{itemize}
    \item \textit{top}: se inicializa como el conjunto formado por todos los subconjuntos de $D$ con $n$ elementos, siendo $n$ la cantidad de \textit{hechos} en D\footnote{Hay un solo subconjunto de $D$ con $n$ elementos: la misma base de datos $D$.}.
    \item \textit{bottom}: se inicializa como el conjunto formado por todos los subconjuntos de $D$ de un solo elemento.
    \item \textit{repairsChicos y repairsGrandes}: estas dos variables se inicializan como el conjunto vacío.
\end{itemize}

El algoritmo consta de un \textit{bucle} principal entre las líneas $9$ y $12$, sobre el cual se irá iterando hasta que alguna de las condiciones que figuran en la línea $9$ no se cumplan. Sea $n$ la cantidad de hechos en $D$ y sea $K$ algún número de iteración en la ejecución del algoritmo. Entonces, en algún momento de esa iteración $k$ se cumplirán las siguientes condiciones: 

\begin{itemize}
    \item \textit{Top} es el conjunto formado por todos los subconjuntos $t$ de $D$ que no son subconjunto de ningún \textit{repair} y tales que $|t| = n + 1 - k$ para todo $t$. Esto es consecuencia de los lemas \ref{tamano_top_2} y \ref{repairs_grandes_agregados}.
    \item \textit{Bottom} es el conjunto formado por todos los subconjuntos consistentes $b$ de $D$ tales que  $|b| = k$ (lema \ref{lemma_bottom}).
    \item Todos los \textit{repairs} $r$ tales que $r = |k|$ serán agregados al conjunto \textit{repairsChicos} (lema \ref{lema_iteracion_k_repairsChicos}).
    \item El conjunto \textit{repairsGrandes} es el conjunto formado por todos los \textit{repairs} $r$ tales que $r > n - k$ (lema \ref{fin_iteracion_k_repairs}).
\end{itemize}

En la demostración formal que presentamos en la sección \ref{demostracion_formal}, probaremos que el \textit{output} de \textit{RepairsFinder} es correcto. Teniendo en cuenta que el algoritmo retorna la unión de los conjuntos \textit{repairsGrandes} y \textit{repairsChicos}, probar lo anterior es similar a afirmar que la unión de los conjuntos \textit{repairsGrandes} y \textit{repairsChicos} es igual al conjunto de \textit{repairs} para la base de conocimiento sobre la cual se haya evaluado \textit{RepairsFinder}.

En la figura \ref{fig:espacio_busqueda_repair_finder_1} representamos el espacio de búsqueda del algoritmo \textit{RepairsFinder}.  A medida que se ejecuten las iteraciones del algoritmo, las variables \textit{top} y \textit{bottom} se moverán en ese espacio, mostrándose en la figura los valores a donde \textit{apuntan} esas variables antes de empezar la primera iteración. En cada iteración, \textit{top} \textit{"bajará"} un nivel en ese espacio y \textit{bottom} \textit{"subirá"} un nivel. Mostramos en la figura \ref{fig:espacio_busqueda_repair_finder_2} los nuevos valores que tomarán estos conjuntos antes de comenzar la segunda iteración, de manera de ilustrar como van cambiando estas variables a medida que se ejecuta el algoritmo. Cabe mencionar aquí que los \textit{repairs} que se agreguen a \textit{repairsGrandes} serán aquellos elementos en \textit{top} que cumplan las condiciones necesarias para garantizar que esos conjuntos son verdaderamente \textit{repairs}. Análogamente, los \textit{repairs} que se agreguen a \textit{repairsChicos} serán aquellos elementos en \textit{bottom} que cumplan con aquellas mismas condiciones.

\begin{figure}[ht]
    \includegraphics[scale=0.3]{espacio_busqueda_repairfinder_iteracion_1.png}
    \centering
    \caption{Espacio de búsqueda RepairsFinder - iteración 1.}
    \label{fig:espacio_busqueda_repair_finder_1}
\end{figure}

\begin{figure}[ht]
    \includegraphics[scale=0.3]{espacio_busqueda_repairfinder_iteracion_2.png}
    \centering
    \caption{Espacio de búsqueda RepairsFinder - iteración 2.}
    \label{fig:espacio_busqueda_repair_finder_2}
\end{figure}

Describiremos ahora de manera informal como funciona el algoritmo. Notemos que en cada iteración se llama a las funciones \textit{IterarTop} e \textit{IterarBottom}. La función \textit{IterarTop} procede de la siguiente manera: para cada elemento $t$ en \textit{top} miramos si es superconjuto de algún \textit{culprit}, y en caso afirmativo lo marcamos como inconsistente. En caso negativo lo validamos de la manera usual, es decir consultando la \textit{KB}. Finalmente si $t$ resulta consistente, será agregado al conjunto de \textit{repairsGrandes}. 

A su vez, la función \textit{IterarBottom()} procede como se describe a continuación. Primero se define el conjunto \textit{proximoBottom} como el conjunto de todos los subconjuntos posibles de $D$ de cardinalidad $k + 1$ que no sean superconjunto de ningún \textit{culprit}. Para cada uno de ellos verificamos si son subconjunto de algún elemento en \textit{repairsGrandes}, y en caso afirmativo los marcamos como consistentes. En caso contrario verificamos consistencia consultando la \textit{KB}. Para todos aquellos que resulten inconsistentes los agregamos al conjunto de \textit{culprits}. Por otro lado, todos los elementos de \textit{bottom} que no sean subconjunto de algún elemento consistente en \textit{proximoBottom} podemos afirmar que son un \textit{repair}, y los agregamos al conjunto de \textit{repairsChicos}. Finalmente, en la próxima iteración, \textit{bottom} estará definido por todos los elementos en \textit{proximoBottom} que sean consistentes.

\subsection{Demostración Formal de correctitud del algoritmo RepairsFinder}\label{demostracion_formal}

\newtheorem{theorem}{Teorema} 
\newtheorem{lemma}[theorem]{Lema}

\begin{theorem}
Dada una \textit{KB} = $(D, \Sigma)$, el algoritmo \textit{RepairsFinder} computa exactamente el conjunto de \textit{repairs} para esa base de conocimiento.
\end{theorem}

\begin{proof}
Sea $repairs(D, \Sigma)$ el conjunto de \textit{repairs} para una base de conocimiento $(D, \Sigma)$. Para probar este teorema necesitamos demostrar que:
 
\begin{enumerate}[(A)] % (a), (b), (c), ...
\item Dado un \textit{r} cualquiera en el \textit{output} de $RepairsFinder(D, \Sigma)$, $r$ pertenece al conjunto $repairs(D, \Sigma)$.
\item Dado un \textit{r} cualquiera perteneciente al conjunto $repairs(D, \Sigma)$, $r$ pertenece al \textit{output} de $RepairsFinder(D, \Sigma)$.
\end{enumerate}

Es decir, necesitamos ver que el primer conjunto está incluido en el segundo y el segundo en el primero, lo cual demostrará que ambos son el mismo conjunto.

Demostremos primero que (A) es verdadero. Veamos entonces que dado un \textit{r} cualquiera en el \textit{output} de $RepairsFinder(D, \Sigma)$, $r$ pertenece al conjunto $repairs(D, \Sigma)$.

Para probar esto, veamos que $r$ cumple las tres cualidades necesarias para ser un \textit{repair}:

\begin{enumerate}[(1)]
    \item $r$ es consistente con respecto a $\Sigma$.
    \item $r$ es un subconjunto de $D$.
    \item $r$ es maximal, es decir que no existe $r\prime \supset r$ tal que (1) y (2) valen para $r\prime$.
\end{enumerate}

Dado que el \textit{output} de \textit{RepairsFinder} está compuesto por la unión entre \textit{repairsChicos} y \textit{repairsGrandes}, podemos contemplar ahora dos casos, o bien $r$ pertenece a \textit{repairsChicos} o bien $r$ pertenece a \textit{repairsGrandes}.

\begin{center}
Caso 1: $r \in repairsGrandes$.
\end{center}

Asumamos entonces que $r \in repairsGrandes$ y veamos que se cumplen las tres condiciones enumeradas anteriormente.

(1) $r$ es consistente: Notemos que \textit{RepairsFinder} solo agrega elementos a \textit{repairsGrandes} en la línea 5 de la función \textit{AgregarConsistentesEnTopARepairs} y que en esa misma línea, en la cláusula del \textit{if} se verifica consistencia. Por lo tanto,  si $r$ pertenece a \textit{repairsGrandes}, entonces $r$ es consistente.

(2) $r$ es un subconjunto de $D$: Si $r$ fue agregado a \textit{repairsGrandes}, entonces $r$ es un elemento que perteneció al conjunto \textit{top} para alguna iteración $k$ del algoritmo. Para verificar esto, notar que tal como se dijo en el párrafo anterior, solo se agregan elementos a \textit{repairsGrandes} en la línea 5 de la función \textit{AgregarConsistentesEnTopARepairs}, y que en esa línea se agrega el elemento $t$ al conjunto, donde $t$ es un elemento perteneciente a \textit{top}. Notemos entonces que \textit{top} se define por primera vez en la tercera línea del algoritmo \textit{RepairsFinder} como el conjunto formado por todos los subconjuntos de $D$ de $n$ elementos\footnote{Trivialmente hay un solo subconjunto de $D$ de $n$ elementos.}. Notemos también, que en cada iteración del algoritmo, el conjunto \textit{top} se redefine en la función \textit{IterarTop} como un conjunto formado por $k$ elementos de $D$, donde $k = nTop - 1$.

(3) $r$ es maximal:  Vimos que si $r$ se agregó a \textit{repairsGrandes} este fue agregado en la línea 5 de la función \textit{AgregarConsistentesEnTopARepairsGrandes}. Notemos ahora que hay dos casos posibles, o bien la llamada a esta función se ejecutó desde la función \textit{IterarTop} en alguna iteración $k$ del \textit{while} principal del algoritmo \textit{RepairsFinder} (caso I) o bien la llamada a \textit{AgregarConsistentesEnTopARepairsGrandes} se ejecutó fuera del ciclo, en la linea 14 del algoritmo \textit{RepairsFinder} (caso II).

Caso I: Sea $k$ el número de iteración en el que $r$ fue agregado a \textit{repairsGrandes}. Teniendo en cuenta que $r$ es un elemento perteneciente a \textit{top} en la iteración $k$, y considerando el lema \ref{tamano_top_2}, resulta entonces que $|r| = n + 1 - k$. Considerando el mismo lema, $r$ no es subconjunto de ningún elemento en \textit{repairsGrandes}.
Por el lema \ref{repairs_grandes_agregados}, todos los \textit{repairs} de cardinalidad mayor estricta que $n + 1 - k$ están en el conjunto \textit{repairsGrandes}. Por lo tanto, $r$ no es subconjunto propio de ningún \textit{repair}. Por absurdo asumamos que $r$ no es maximal, es decir asumamos que existe un subconjunto $s \subseteq D$ tal que $s$ es consistente y $r \subset s$. Existen dos opciones, o bien $s$ es un \textit{repair} o bien $s$ está incluido en un \textit{repair}. En ambos casos resulta que $r$ es un subconjunto propio de algún \textit{repair}, lo cual es absurdo, pues dijimos que por los lemas 4 y 6 $r$ no es subconjunto propio de ningún \textit{repair}.

Caso II: Sea $k$ la última iteración que se ejecutó del ciclo \textit{RepairsFinder} antes de la llamada a \textit{AgregarConsistentesEnTopARepairsGrandes} en la línea 14 del algoritmo. Teniendo en cueneta que $r$ es un elemento de \textit{top}, y considerando el lema \ref{fin_iteracion_k_top}, resulta entonces que $|r| = n - k$. Considerando el mismo lema, $r$ no es subconjunto de ningún elemento en \textit{repairsGrandes}.
Por el lema \ref{fin_iteracion_k_repairs}, todos los \textit{repairs} de cardinalidad mayor estricta que $n - k$ están en el conjunto \textit{repairsGrandes}. Por lo tanto, $r$ no es subconjunto propio de ningún \textit{repair}. Al igual que en el caso I asumamos por absurdo que $r$ no es maximal. Siguiendo el mismo razonamiento concluimos que $r$ es un subconjunto propio de algún \textit{repair}, lo cual es absurdo, pues dijimos que $r$ no es  subconjunto propio de ningún \textit{repair}.

\begin{center}
Caso 2: $r \in repairsChicos$.
\end{center}

Asumamos entonces que $r \in repairsChicos$ y veamos que también se cumplen las tres condiciones.

(1) $r$ es consistente: Notemos que solo se agregan elementos a \textit{repairsChicos} en la línea 11 de la funcion \textit{IterarBottom}. Notemos además que esa línea dice "\textit{repairsChicos.agregar(b)}", donde $b$ es un elemento en \textit{bottom}. Debemos probar entonces que los elementos en \textit{bottom} al momento de ejecutarse tal línea del algoritmo, son subconjuntos consistentes. Podemos ahora separar nuevamente en dos casos: o bien $r$ fue agregado en la primera iteración del algoritmo \textit{RepairsFinder}, o bien $r$ fue agregado en alguna iteración posterior. En el primer caso, la última asignación del conjunto \textit{bottom} previa a la ejecución de tal línea fue en la línea 5 de la función \textit{InicializarBottom} como un conjunto de subconjuntos consistentes. En el segundo caso, el conjunto \textit{bottom} fue redefinido en la iteración anterior del ciclo en la línea 14 de la función \textit{IterarBottom}, otra vez como un conjunto de subconjuntos consistentes. Por lo tanto, si $r$ pertenece a \textit{repairsChicos}, entonces $r$ es consistente.

(2) $r$ es un subconjunto de $D$: Si $r$ fue agregado a \textit{repairsChicos}, entonces $r$ estaba en el conjunto \textit{bottom}, que está definido en toda iteración del \textit{while} principal como un conjunto de subconjuntos de $k$ elementos de $D$. Para verficar esto, notemos que \textit{bottom} se inicializa en la línea 4 del algoritmo \textit{RepairsFinder} como el conjunto formado por todos los subconjuntos de un elemento de $D$. Veamos además que en cada iteración, \textit{bottom} se redefine en la línea 14 de la función \textit{IterarBottom} como todos los elementos consistentes de \textit{proximoBottom}, donde \textit{proximoBottom} está definido como un conjunto formado por subconjuntos de \textit{nBottom + 1} elementos de $D$, donde \textit{nBottom} siempre vale igual al número de iteración que se está ejecutando.

(3) $r$ es maximal: Sea $r$ un elemento en \textit{repairsChicos}. Asumamos por absurdo que $r$ no es maximal; es decir que existe un elemento $\alpha \in D$ tal que $\alpha \not\in r$ y $r \cup \{\alpha\}$ es consistente. Llamamos $c$ al conjunto $r \cup \{\alpha\}$. Sea $k$ el número de iteración en el que $r$ fue agregado a \textit{repairsChicos}. Considerando la línea 11 de la función \textit{IterarBottom} es fácil ver que si $r$ fue agregado a \textit{repairsChicos} entonces $r$ perteneció al conjunto \textit{bottom} en esa iteración $k$. Por el lema \ref{bottom_cardinalidad_k} sabemos además que entonces $|r| = k$. Veamos además que en esa iteración $k$, el conjunto $c$ perteneció a \textit{proximoBottom}. Para afirmar esto tenemos en cuenta el lema \ref{proximoBottom_cardinalidad_k}, el cual dice que en una iteración $k$, si un subconjunto $s$ de $D$ tiene cardinalidad $k+1$ y no es superconjunto de ningun \textit{culprit}, entonces al ejecutarse la línea 9 de la función \textit{IterarBottom}, $s$ está en \textit{proximoBottom}. Trivialmente, $|c| = k+1$, y además por el lema \ref{culprits_inconsistentes}, $c$ no puede ser superconjunto de ningún elemento en \textit{culprits}, pues $c$ es consistente.
Tengamos en cuenta ahora que en la linea 10 de \textit{IterarBottom} la cláusula del \textit{if} determina que solo se agregará $r$ a \textit{repairsChicos} cuando todos los conjuntos en \textit{proximoBottom} que sean superconjunto de $r$ no sean consistentes. Por lo tanto, en esa iteración no se pudo haber agregado $r$ a \textit{repairsChicos}, pues $c$ esta en \textit{proximoBottom} y $c$ es superconjunto de $r$ y $c$ es consistente. Pero esto es absurdo, pues dijimos que $r$ fue agregado a \textit{repairsChicos} en esa iteracion $k$.

Habiendo probado (1), (2) y (3) para el caso $r \in repairsChicos$ y para el caso  $r \in repairsGrandes$ hemos probado que (A) es verdadero. 

Probemos ahora que (B) es verdadero. Es decir veamos que dado un \textit{repair} $r_0$ perteneciente al conjunto de $repairs(D, \Sigma)$, $r_0$ se encuentra en el \textit{output} de \textit{repairsFinder(D, $\Sigma$)}.

Sea $n = |D|$ y separemos en los siguientes cuatro casos:

\begin{enumerate}[(1)]
    \item $n$ par y $|r_0| > \parteEntera$
    \item $n$ impar y $|r_0| > \parteEntera + 1$
    \item $n$ par o impar y  $|r_0| \leq \parteEntera$
    \item $n$ impar y $|r_0| = \parteEntera + 1$
\end{enumerate}


\begin{center}
\underline{Caso (1): $n$ par y $|r_0| > \parteEntera$}
\end{center}
 
Notemos que por el lema \ref{repairs_grandes_agregados}, en caso de que se haya ejecutado la iteración $k = n - |r_0| + 1$, todos los \textit{repairs} $r$ tales que $|r| \geq n - k + 1$ habrán sido agregados al conjunto \textit{repairsGrandes}. Pero $k = n - |r_0| + 1$, por lo tanto $n - k + 1 = |r_0|$. Es decir que si se ejecutó la iteración $k$ todos los \textit{repairs} $r$ tales que $r \geq |r_0|$ habrán sido agregados a \textit{repairsGrandes}, por lo tanto, en particular $r_0$ habrá sido agregado a \textit{repairsGrandes}. Queremos ver entonces que esta iteración $k$ se ejecutó.

Asumamos por absurdo que esta iteración no se ejecutó. Es decir asumamos que la última iteración ejecutada fue la iteración $j$ con $j < k$. Notemos que por la condición del \textit{while} en la línea 9 del algoritmo \textit{repairsFinder}, la última iteración que se ejecutará será la que haga valer alguna de las tres condiciones siguientes:

\begin{enumerate}[(a)]
    \item $bottom = \emptyset$
    \item $top = \emptyset$
    \item $nBottom \geq nTop$
\end{enumerate}

Asumamos por absurdo que una vez ejecutada la iteración $j$ vale alguna de esas tres condiciones.

Condición (a): \underline{\textit{bottom} = $\emptyset$}: En este caso, teniendo en cuenta que la variable \textit{bottom}  se definió por última vez en la línea 14 de la función \textit{iterarBottom} durante la iteración $j$, teniendo en cuenta que \textit{proximoBottom} es en este caso el conjunto de todos los subconjuntos $s \subset D$, con $|s| = nBottom + 1$ tales que no son superconjunto de ningún elemento en \textit{culprits}, y teniendo en cuenta que por el lema \ref{culprits_inconsistentes} todos los \textit{culprits} son inconsistentes podemos decir que, gracias al lema \ref{for_proximo_bottom}, si la variable \textit{bottom} es el conjunto vacío entonces todos los subconjuntos $s \subset D$ con $|s| = j + 1$ son inconsistentes\footnote{Notemos que al ejecutarse la línea 1 de la función \textit{iterarBottom} en la iteración $j$ la variable \textit{nBottom} vale j, pues \textit{nBottom} vale 1 en la primera iteración y se incrementa en un valor en cada iteración.}.

Por el lema lema \ref{maxima_cantidad_de_iteraciones} $j\leq \parteEntera$, y por lo tanto $|r_0| > j$. Hay dos opciones, o bien $|r_0| = j + 1$, o bien $|r_0| > j + 1$. En el caso $|r_0| = j + 1$, dado que todos los subconjuntos $s \in D$ tales que $|s| = j + 1$ son inconsistentes, resulta que $r_0$ es inconsistente, lo cual es absurdo. En el caso $|r_0| > j + 1$, sea $s$ algún subconjunto tal que $s \subset r_0$ con $|s| = j + 1$. Resulta entonces que $s$ es inconsistente y $s$ es subconjunto de un \textit{repair}. Absurdo. 

Condición (b): \underline{top = $\emptyset$}: En este caso, la línea 2 de la función \textit{iterarTop} retornó el conjunto vacío durante la ejecución de la iteración $j$, lo cual significa que todos todos los subconjuntos de $D$ con cardinalidad $nTop - 1$ son subconjuntos de algún elemento en \textit{repairsGrandes}. Teniendo en cuenta el lema \ref{repairs_grandes_agregados} todos los \textit{repairs} $r$ tales que $r > n + 1 - j$ ya están en \textit{repairsGrandes}. Además, por el el lema \ref{repairs_grandes_agregados_en_iteracion_k}, durante la ejecución de la llamada a la función \textit{AgregarConsistentesEnTopARepairs}, todos los \textit{repairs} $r$ tales que $|r| = n - j + 1$, y solamente ellos, serán agregados al conjunto \textit{repairsGrandes}. Considerando entonces estos dos lemas, al momento de ejecutarse la línea 2 de esta función, el conjunto \textit{repairsGrandes} es el conjunto de todos los \textit{repairs} $r$ tales que $|r|\geq n + 1 - j$. Considerando ahora que $nTop - 1 = n -j$, si la línea 2 de esta función retornó vacío durante la ejecución de la iteración $j$, esto significa que todos los subconjuntos $s \subset D$ tales que $|s| = n - j$ son subconjuntos propios de algún \textit{repair}. 



Dijimos que $j < k$, y por lo tanto $n - j > n - k$, con lo cual resulta que $n - j \geq n - k + 1 =|r_{0}|$. Si $n - j = |r_{0}|$ entonces por lo dicho en el párrafo anterior $r_0$ es subconjunto propio de algún \textit{repair}, lo cual es absurdo. Si $n - j > |r_0|$ entonces tomo algún subconjunto $s$ tal que $r_0 \subset s$ con $|s| = n - j$. Dado que $s$ es subconjunto propio de algún \textit{repair} $r$ resulta que $r_0 \subset r$, lo cual es absurdo.

Condición (c): \underline{$\textit{nBottom} \geq \textit{nTop}$}: Dado que $\textit{nBottom}$ se inicializa en 1, y dado que \textit{nTop} se inicializa en n, y teniendo en cuenta que el primero incrementa de a un valor por iteración, y que el segundo decrementa también de a un valor por iteración, este caso solo puede ocurrir cuando ya se hayan ejecutado $\parteEntera$ iteraciones. Asumamos por absurdo que no se ejecutó la iteración $n - |r_0| + 1$. Dado que $n$ es par resulta que $n - \parteEntera = \parteEntera$. Dado que $|r_0| > \parteEntera$, resulta entonces que $n - |r_0| < \parteEntera$, y por lo tanto $n - |r_0| + 1 \leq \parteEntera$. Pero esto es absurdo, pues si se ejecutó la iteración $\parteEntera$ también se ejecuto la iteración $n - |r_0| + 1$.

Concluimos entonces que sería absurdo que alguna iteración $j<k$ con $k = n - |r_0| + 1$ haga valer alguna de las condiciones (a), (b) o (c). Por lo tanto, para el caso (1): $n$ par y $|r_0| > \parteEntera$, resulta que la iteración $k$ tuvo que haberse ejecutado, y entonces por el lema \ref{repairs_grandes_agregados}, $r_0$ habrá sido agregado a \textit{repairsGrandes}.

\begin{center}
\underline{Caso (2): $n$ impar y $|r_0| > \parteEntera + 1$}
\end{center}


Al igual que en el caso anterior, queremos ver que se ejecuto la iteración $k = n - |r_0| + 1$. Asumamos nuevamente por absurdo que la máxima iteración que se ejecutó fue la iteración $j$ con $j < k$. Quiero ver nuevamente que la iteración $j$ no puede hacer valer ninguna de las condiciones (a), (b) o (c).

Condición (a): \underline{\textit{bottom} = $\emptyset$}: Si \textit{bottom} es vacío después de haberse ejecutado la iteración $j$, entonces todos los subconjuntos $s \subseteq D$ tales que $|s| = j + 1$ son inconsistentes. Por el lema \ref{maxima_cantidad_de_iteraciones}, tenemos que $j\leq \parteEntera$. Por lo tanto $j+1 \leq \parteEntera + 1$, es decir que $j + 1 < |r_0|$. Sea $s$ tal que $|s| = j + 1$ y $s \subset r_0$. Esto es absurdo pues $s$ s es inconsistente.

Condición (b): \underline{\textit{top} = $\emptyset$}: En este caso la demostración es exactamente igual para la condición (b) en el caso (1): $n$ par, $|r_0| > \parteEntera$ y \textit{top} = $\emptyset$. 

Condición (c): \underline{$\textit{nBottom} \geq \textit{nTop}$}: Al igual que en el caso (1) esto solo puede ocurrir cuando ya se hayan ejecutado $\parteEntera$ iteraciones\footnote{En el caso (1) la condición $\textit{nBottom} \geq \textit{nTop}$ será verdadera cuando se cumpla $\textit{nBottom} = \parteEntera + 1$ y $\textit{nTop} = \parteEntera$. Mientras que en este caso la condición se cumplirá cuando $\textit{nTop} = \textit{nBottom} = \parteEntera + 1$.}. Asumamos por absurdo que no se ejecutó la iteración $n - |r_0| + 1$. Dado que $n$ es impar resulta que $n - \parteEntera = \parteEntera + 1$. Por lo tanto, $|r_0| > n - \parteEntera$, con lo cual $|r_0| \geq n - \parteEntera + 1$, es decir  $n - |r_0| + 1 =< \parteEntera$. Pero la iteración $\parteEntera$ se ejecutó y una iteración menor no se ejecutó, lo cual es absurdo.

Concluimos entonces que para el caso (2), sería absurdo, al igual que en el caso (1), que una iteración $j<k$ con $k = n - |r_0| + 1$ haga valer alguna de las condiciones (a), (b) o (c). Por lo tanto, para el caso (2): $n$ impar y $|r_0| > \parteEntera + 1$, resulta que la iteración $k$ tuvo que haberse ejecutado, y entonces por el lema \ref{repairs_grandes_agregados}, $r_0$ habrá sido agregado a \textit{repairsGrandes}.

\begin{center}
\underline{Caso (3): $|r_0| \leq \parteEntera$}
\end{center}

Este caso es independiente de que $n$ sea par o impar. Queremos ver que se ejecutó la iteración $k = |r_0|$, pues si se ejecutó tal iteración, por el lema \ref{lema_iteracion_k_repairsChicos} todos los \textit{repairs} $r$ tales que $r = |r_0|$ están en \textit{repairsChicos}, por lo tanto en particular también lo estará $r_0$.

Asumamos por absurdo que no se ejecutó tal iteración. Sea $j$ la última iteración que se ejecutó, con $j<k$. Demostremos nuevamente por absurdo, que la iteración $j$ no puede hacer valer ninguna de las condiciones (a), (b) o (c).

Condición (a): \underline{\textit{top} = $\emptyset$}: En este caso, evaluando la línea 2 de la función \textit{iterarTop}, todos los subconjuntos $s$ de $D$ tal que $|s| = n - j$ son subconjuntos propios de algún \textit{repair}. Dijimos que $j < k$, por lo tanto, teniendo en cuenta que estamos en el caso $|r_0| \leq \parteEntera$, resulta que $j < \parteEntera$. Esto implica, tanto para el caso par como para el caso impar, que $n - j > \parteEntera$, y esto implica que $|r_0| < n - j$. En particular tomo algún $s$ con $|s| = n - j$ tal que $r_0 \subset s$. Pero $s$ es subconjunto propio de algún \textit{repair} y entonces $r_0$ también lo es, lo cual es un absurdo.

Condición (b): \underline{\textit{bottom} = $\emptyset$}: En este caso, evaluando la línea 14 de la función \textit{iterarBottom}, todos los subconjuntos s tales que $|s| = j + 1$ son inconsistentes. Dijimos que $j<k$, esto implica que $j + 1 \leq k$, es decir $j + 1 \leq |r_0|$. En el caso $j + 1 = |r_0|$, resulta que $r_0$ es inconsistente, lo cual es absurdo. En el caso  $j + 1 < |r_0|$ tomo algún $s$ tal que $|s| = j + 1$ y $s \subset r_0$. Pero $r_0$ es superconjunto de un conjunto inconsistente. Por lo tanto $r_0$ es inconsistente, lo cual es un absurdo.

Condición (c): \underline{$\textit{nBottom} \geq \textit{nTop}$}: Esto solo puede pasar cuando ya se ejecutaron $\parteEntera$ iteraciones. Asumamos que no se ejecutó la iteración $|r_0|$, pero $|r_0| \leq \parteEntera$, por lo tanto es absurdo que no se haya ejecutado esa iteración.

Concluimos entonces que para el caso (3), tuvo que haberse ejecutado necesariamente la iteración $k = |r_0|$, pues demostramos por absurdo que una iteración $j<k$ haga valer alguna de las condiciones (a), (b) o (c). Por lo tanto, por el lema \ref{lema_iteracion_k_repairsChicos}, $r_0$ será agregado al conjunto \textit{repairsChicos} y se encontrará en el \textit{output} de \textit{RepairsFinder}.  

\begin{center}
\underline{Caso (4): $n$ impar y $|r_0| = \parteEntera + 1$}
 \end{center}

Veamos primero que en este caso se tuvieron que ejecutar necesariamente $\parteEntera$ iteraciones. Para esto veamos que la condición del \textit{while} en la línea 9 del algoritmo solo será falsa cuando $\textit{nTop} = \textit{nBottom}$, es decir veamos que las condiciones $\textit{top} \neq \emptyset$ y que la condición $\textit{bottom} \neq \emptyset$ serán siempre verdaderas durante las $\parteEntera$ iteraciones, que por el lema \ref{maxima_cantidad_de_iteraciones} es el máximo de iteraciones que se pueden ejecutar. 

Asumamos por absurdo que después de alguna iteración $j$ resulta $\textit{bottom} = \emptyset$. Esto significa que todos los subconjuntos $s \subset D$ con $|s| = j$ son inconsistentes. Dijimos que por el lema \ref{maxima_cantidad_de_iteraciones} $j \leq \parteEntera$. Tomo algún conjunto $s$ particular tal que $|s| = j$ y $s \subset r_0$. Pero esto es absurdo, pues $r_0$ es un \textit{repair} y es superconjunto de un conjunto inconsistente. 

Asumamos ahora por absurdo que después de alguna iteración $j$ resulta $\textit{top} = \emptyset$. Esto significa que todos los subconjuntos $s \subset D$ con $|s| = n - j$ son subconjuntos propios de algún \textit{repair}. Pero dado que $j \leq \parteEntera$ resulta que $ n - j \geq \parteEntera + 1$, pues $n$ es impar. En el caso $n - j = \parteEntera + 1$, teniendo en cuenta que estamos en el caso $|r_0| = \parteEntera + 1$ resulta que $r_0$ es subconjunto propio de algún \textit{repair}, lo cual es absurdo. En el caso $ n - j > \parteEntera + 1$, tomo algún $s$ tal que $|s| = n - j$ y $r_0 \subset s$. En este caso $r_0$ es subconjunto propio de un conjunto que es subconjunto propio de algún \textit{repair}, lo cual es absurdo.

Teniendo en cuenta los dos absurdos, probamos que se han ejecutado las $\parteEntera$ iteraciones y por lo tanto, al ser $n$ impar resulta que $\textit{nBottom} = \textit{nTop} = \parteEntera + 1$. Por lo tanto la condición del \textit{if} en la línea 13 del algoritmo es verdadera, pues se cumple $\textit{nBottom} = \textit{nTop}$ y se cumple $\textit{top} \neq \emptyset$. Esto significa que se va a ejecutar otra vez la llamada a la función \textit{AgregarConsistentesEnTopARepairs}, y por lo tanto, teniendo en cuenta que la última asignación de la variable $\textit{top}$ fue en la iteración $\parteEntera$, y teniendo en cuenta el lema \ref{fin_iteracion_k_repairs} resulta que $\textit{top}$ es el conjunto de todos los subconjuntos $s \subseteq D$ tales que $|s| = \parteEntera + 1$ y $s$ no es subconjunto propio de ningún \textit{repair}. Por lo tanto $r_0$ tiene que estar en $\textit{top}$. Teniendo en cuenta ahora el lema \ref{f_agregar_consistentes_en_top_a_repairs} resulta que $r_0$ será agregado a \textit{repairsGrandes}.

Hemos probado entonces el caso (4), es decir que en este caso $r_0$ también estará en el \textit{output} de \textit{RepairsFinder}.

Habiendo entonces probado los casos (1), (2), (3) y (4), hemos probado que (B) es verdadero.
\end{proof}

\begin{lemma}\label{bottom_cardinalidad_k}
Sea $k$ un número de iteración en la ejecución del algoritmo \textit{RepairsFinder}. Entonces, al momento de ejecutarse la linea 9 de la función \textit{IterarBottom}, todos los elementos en \textit{bottom} son subconjuntos de $D$ de $k$ elementos.
\end{lemma}

\begin{proof}
Para el caso $k = 1$, vemos que el conjunto \textit{bottom} se inicializó en la línea 4 del algoritmo \textit{RepairsFinder} como un conjunto formado por todos los subconjuntos de un elemento de $D$. Para el caso $k>1$ notemos que la última asignación a la variable \textit{bottom} fue en la iteración $k-1$ en la línea 14 de la función \textit{iterarBottom}. En esa línea se redefine a \textit{bottom} como todos los elementos de \textit{proximoBottom} consistentes. Necesitamos ver entonces que en esa iteración $k-1$ los elementos en \textit{proximoBottom} tienen cardinalidad $k$, lo cual queda probado por el lema \ref{proximoBottom_cardinalidad_k}\footnote{Consideramos el cambio de variable, $j = k-1$. Si en la iteración $k$ todos los elementos en \textit{proximoBottom} tienen $k+1$ elementos, entonces en la iteración $j = k-1$ todos los elementos en \textit{proximoBottom} tienen $j + 1 = k$ elementos al ejecutarse la línea 9 de la función \textit{IterarBottom}.} .
\end{proof}

\begin{lemma}\label{proximoBottom_cardinalidad_k}
Sea $k$ una iteración en el algoritmo \textit{RepairsFinders}. Entonces, al momento de ejecutarse la línea 9 de la función \textit{IterarBottom}, el conjunto \textit{proximoBottom} consta de todos los subconjuntos de $k + 1$ elementos que no son superconjunto de ningún \textit{culprit}.
\end{lemma}

\begin{proof}
Trivialmente, al comienzo de cada iteración $k$, la variable \textit{nBottom} guarda el valor $k$, pues esta se asigna en 1 antes de la primera iteración y se incrementa en una unidad al final de cada iteración. Teniendo en cuenta entonces que la variable \textit{proximoBottom} se asigna únicamente en la línea 1 de la función \textit{IterarBottom} como todos los subconjuntos de  $D$ de $nBottom + 1$ elementos que no sean superconjunto de ningún \textit{culprit}, el lema queda probado.
\end{proof}


\begin{lemma}\label{tamano_top_2}
Sea $k$ un número de iteración en la ejecución del algoritmo \textit{RepairsFinder}. Entonces, al momento de llamarse la función \textit{AgregarConsistentesEnTopARepairs} para esa iteración $k$, el conjunto \textit{top} es exactamente el conjunto de todos los subconjuntos $t$ de $D$ tales que $|t| = n + 1 - k$ con $t \not\subset r$ para todo $r$ en \textit{repairsGrandes}.
\end{lemma}

\begin{proof}
Notemos que para el caso $n=1$ esto es trivial, pues en esta iteración el único subconjunto de $D$ con $n + 1 - k = n$ elementos es el mismo conjunto $D$. Y notemos que justamente en esa iteración, $top$ consta justamente de un solo elemento, el conjunto $D$. Veamos además que en esta iteración al momento de llamarse la función \textit{AgregarConsistentesEnTopARepairs}, el conjunto \textit{RepairsGrandes} es el conjunto vacío, por lo tanto, de manera trivial, ningún elemento en \textit{top} es subconjunto de algun $r$ en \textit{repairsGrandes}.

Para el caso $k \geq 2$ el conjunto \textit{top} fue definido en la la línea 2 de la función \textit{IterarTop} en la ejecución de la iteración $k-1$, por lo tanto resta ver que en la iteración $k-1$ top se definió como el conjunto formado por todos los conjuntos de $n + 1 - k$ elementos que no son subconjuntos de ningún $r$ en \textit{repairsGrandes}. Tomando el cambio de variable $k - 1 = j$, quiero ver que en la iteración $j$, \textit{top} se definió como el conjunto de  todos los conjuntos de $n + 1 - (j + 1)$ elementos. Teniendo en cuenta el primer parámetro que recibe la función subconjuntosDeKElementos\footnote{Asumimos en este punto que la función subconjuntosDeKElementos(k, D) devuelve exactamente el conjunto de todos los subconjuntos de k elementos de D.} en la línea 2 de la función \textit{IterarTop}, quiero ver que en la iteración $j$, $nTop-1=n + 1 - (j + 1)$, es decir $nTop-1=n-j$. Para el caso $j=1$ esto es trivial. Asumamos que para un $j$ cualquiera vale que $nTop-1=n-j$ y veamos que esto implica que vale para la iteración $j+1$. Teniendo en cuenta la línea 3 de esta función, sabemos que en la iteración $j+1$ la variable \textit{nTop} valdrá un valor menos que en la iteración j, por lo tanto queremos ver que $(nTop-1) - 1 = n - (j+1)$. Notemos entonces que $(nTop-1) - 1 = n - (j+1) \iff nTop-1 - 1 = n - j -1 \iff nTop-1 = n - j$, siendo esta igualdad válida por hipótesis inductiva.
Por último, en la línea 2 de aquella función, se excluye explícitamente de \textit{top} a los subconjuntos de \textit{repairsGrandes}.
\end{proof}

\begin{lemma}\label{repairs_grandes_agregados_en_iteracion_k}
Sea $k$ un número de iteración en la ejecución de $repairsFinder(D, \Sigma)$. Entonces, durante la ejecución de la llamada a la función \textit{AgregarConsistentesEnTopARepairs}, todos los \textit{repairs} $r$ tales que $|r| = n - k + 1$, y solamente ellos, serán agregados al conjunto \textit{repairsGrandes}. 
\end{lemma}

\begin{proof}
Probamos este lema por inducción en el número de iteración $k$. Notemos que para probar que el lema vale para $k = 1$ necesitamos probar que el conjunto $D$ será agregado a \textit{repairsGrandes} si solo si $D$ es consistente. Notemos que al momento de llamarse la función \textit{AgregarConsistentesEnTopARepairs} en esta primera iteración, la variable \textit{top} consta de un conjunto que contiene a un único conjunto: el conjunto $D$. Notemos ahora que por el lema \ref{f_agregar_consistentes_en_top_a_repairs} $D$ será agregado a \textit{repairsGrandes} si solo si $D$ es consistente.

Para probar el paso inductivo asumimos que la condición vale para todas las iteraciones entre 1 y $k$ y queremos ver que esto implica que vale para la iteración $k+1$. Es decir, queremos ver que si vale para todas las iteraciones menores a $k+1$, entonces durante la ejecución de la iteración $k+1$, durante la ejecución de la funcion \textit{AgregarConsistentesEnTopARepairs}, se agregaran todos, y solamente aquellos \textit{repairs} $r$ tales que $|r| = (n + 1 - (k+1)) = n - k$.


Asumamos entonces que se está ejecutando la llamada a la función \textit{AgregarConsistentesEnTopARepairs} para la iteración $k+1$. Por el lema \ref{tamano_top_2}, al momento de llamarse a esta función, $top$ consta de exactamente todos los subconjuntos de $D$ con cardinalidad $n - (k + 1) + 1 = n - k$ que no son subconjunto de ningún elemento en \textit{repairsGrandes}. Notemos que si se cumple la hipótesis inductiva, el conjunto \textit{repairsGrandes} es exactamente el conjunto formado por todos los \textit{repairs} $r$ tales que $|r| > n - k$. Juntando esto con lo anterior resulta entonces que $top$ consta de exactamente todos los subconjuntos de $D$ con cardinalidad $n - k + 1$ que no son subconjunto propio de ningún \textit{repair}. 

Veamos ahora que el conjunto de \textit{repairs} de cardinalidad $n-k$ es exactamente igual al subconjunto de $top$ formado por los elementos en $top$ consistentes. Llamamos a este conjunto $topConsistentes$. Veamos entonces las dos inclusiones.
Sea $r$ un \textit{repair} de cardinalidad $n-k$. Queremos ver que $r \in topConsistentes$. Dado que $r$ es un \textit{repair}, no es subconjunto propio de ningún otro \textit{repair}. Además, por ser un \textit{repair}, es consistente. Por lo tanto, $r$ pertenece a $topConsistentes$.
Sea $t$ un elemento en \textit{topConsistentes}, veamos que es un \textit{repair} de cardinalidad $n-k$. Sabemos que su cardinalidad es $n-k$ por el lema \ref{tamano_top_2}. Sabemos además que es consistente y que no es subconjunto propio de ningún \textit{repair}. Entonces por el lema \ref{s_es_un_repair}, $t$ es un \textit{repair}.

Por el lema \ref{f_agregar_consistentes_en_top_a_repairs} solo los elementos en \textit{topConsistentes} serán agregados a \textit{repairsGrandes}, por lo tanto solo los \textit{repairs} de $n-k$ elementos son agregados a \textit{repairsGrandes}.
\end{proof}


\begin{lemma}\label{repairs_grandes_agregados}
Sea $k$ un número de iteración en la ejecución de $repairsFinder(D, \Sigma)$. Entonces, al momento de ejecutarse la llamada a la función \textit{IterarTop} en esa iteración $k$, el conjunto \textit{repairsGrandes} es el conjunto formado por todos los \textit{repairs} $r$ tal que $|r| > (n + 1 - k)$.
\end{lemma}

\begin{proof}
Por el lema \ref{repairs_grandes_agregados_en_iteracion_k} para toda iteración $j$ anterior a $k$ sucedió que solo los \textit{repairs} $r$ tales que $|r| = n - j + 1$ fueron agregados al conjunto \textit{repairsGrandes}. Esto quiere decir que en la primera iteración se agregaron solo los \textit{repairs} de cardinalidad $n$, en la segunda los de $n-1$, y así sucesivamente, en la iteración $k-1$ se agregaron todos los \textit{repairs} de cardinalidad $n-k+1$. Por lo tanto al momento de ejecutarse la iteración $k$ el conjunto \textit{repairsGrandes} es el conjunto formado por todos los \textit{repairs} $r$ tal que $|r| > (n + 1 - k)$.
\end{proof}

\begin{lemma}\label{culprits_inconsistentes}
Sea $c$ un elemento en el conjunto \textit{culprits}. Entonces $c$ es inconsistente.
\end{lemma}

\begin{proof}
Trivialmente, el algoritmo \textit{RepairsFinder} solo agrega elementos a la variable \textit{culprits} si son conjuntos inconsistentes, basta con ver la línea 3 de la función \textit{InicializarBottom} y la línea 6 de la función \textit{IterarBottom} y notar que en ninguna otra línea del algoritmo se agregan elementos a este conjunto.
\end{proof}


\begin{lemma}\label{s_es_un_repair}
Sea $KB$ una base de conocimientos $(D, \Sigma)$ y sea $s$ un subconjunto consistente de $D$. Si $s$ no es subconjunto estricto de ningún \textit{repair}, entonces $s$ es un \textit{repair}.
\end{lemma}

\begin{proof}
Por definición de \textit{repair}, el conjunto $s$ es un \textit{repair} de $(D, \Sigma)$ si solo si $s$ es subconjunto de $D$, $s$ es consistente y $s$ es maximal. Ya sabemos por enunciado del lema que $s$ es subconjunto de $D$ y que es consistente. Solo falta ver que es maximal. Por absurdo asumamos que no es maximal. Es decir que existe un conjunto $c$ que es superconjunto estricto de $s$, tal que $c$ es consitente y subconjunto de $D$. Hay dos opciones, o bien $c$ es un \textit{repair} o bien $c$ es un subconjunto de un \textit{repair}. En ambos casos resulta que $s$ es subconjunto estricto de algún \textit{repair}. Absurdo, el cual provino de suponer que $s$ no es maximal.
\end{proof}

\begin{lemma}\label{f_agregar_consistentes_en_top_a_repairs}
La funcion \textit{AgregarConsistentesEnTopARepairs} agrega solo los elementos consistentes en \textit{top} a \textit{repairsGrandes}.
\end{lemma}

\begin{proof}
Notemos que en la función  \textit{AgregarConsistentesEnTopARepairs} se itera sobre todos los elementos $t$ en \textit{top} y que para cada uno de ellos, $t$ será agregado a \textit{repairsGrandes} si solo si $t$ es consistente. Notemos que para cada $t$ en \textit{top} se verifica que no sea superconjunto de ningún elemento en \textit{culprits}. Por el lema  \ref{culprits_inconsistentes} todos los elementos en \textit{culprits} son inconsistentes, por lo tanto si $t$ es superconjunto de algún $c \in culprits$ entonces $t$ es inconsistente. En este caso $t$ no es agregado a \textit{repairsGrandes}. Caso contrario, $t$ podría ser consistente o podría no serlo. Se verifica consistencia de $t$ de la manera usual, y $t$ es agregado a \textit{repairsGrandes} si solo si $t$ es consistente.
\end{proof}

\begin{lemma}\label{fin_iteracion_k_top}
Sea k un numero de iteración en la ejecución del algoritmo \textit{RepairsFinder}. Entonces, al momento de finalizar tal iteración, el conjunto \textit{top} es exactamente el conjunto de todos los subconjuntos $t$ de $D$ tales que $|t|=n - k$ con $t \not\subset r$ para todo $r$ en \textit{repairsGrandes}.
\end{lemma}
\begin{proof}
Por el lema \ref{tamano_top_2}, al momento de arrancar la iteración $k$, el conjunto  \textit{top} es exactamente el conjunto de todos los subconjuntos $t$ de $D$ tales que $|t| = n + 1 - k$ con $t \not\subset r$ para todo $r$ en \textit{repairsGrandes}. Notemos que esto quiere decir que al final de la iteracion $k - 1$ \textit{top} era exactamente ese mismo conjunto, pues el momento en el que finaliza la iteracion $k - 1$ es el mismo momento que el que comienza la iteración $k$. Haciendo un cambio de variable, tomando $j = k -1$ podemos decir entonces que al momento de terminar la iteracion $j$ el conjunto \textit{top} es exactamente el conjunto de todos los subconjuntos $t$ de $D$ tales que $|t|=n - j = n - (1 + k)$, tales que $t \not\subset r$ para todo $r$ en \textit{repairsGrandes}.
\end{proof}

\begin{lemma}\label{fin_iteracion_k_repairs}
Sea $k$ un número de iteración en la ejecución de \textit{RepairsFinder}. Entonces, al momento de finalizar tal iteracion $k$, el conjunto \textit{repairsGrandes} es el conjunto formado por todos los \textit{repairs} $r$ tal que $|r|>n-k$.
\end{lemma}

\begin{proof}
Por el lema \ref{repairs_grandes_agregados}, al momento de llamarse a la función \textit{AgregarConsistentesEnTopARepairs} en la iteración $k$, el conjunto \textit{repairsGrandes} consta de exactamente todos los \textit{repairs} $r$ tales que $r < |n - k + 1|$. Por el lema \ref{repairs_grandes_agregados_en_iteracion_k}, durante la ejecución de la función \textit{AgregarConsistentesEnTopARepairs} se agregarán a \textit{repairsGrandes} exactamente todos los \textit{repairs} $r$ tales que $|r| = n - k + 1$. Por lo tanto, una vez finalizada la iteracion $k$, el conjunto \textit{repairsGrandes} es exactamente el conjunto de todos los \textit{repairs} $r$ tales que $|r| > n -k $.
\end{proof}


\begin{lemma}\label{lema_iteracion_k_repairsChicos}
Sea $k$ una iteración en la ejecución del algoritmo \textit{repairsFinder}. Entonces, al finalizar tal iteración, todos los \textit{repairs} $r$ tal que $|r| = k$ han sido agregados al conjunto \textit{repairsChicos}.
\end{lemma}

\begin{proof}
Sea entonces el momento en el que se va a ejecutar el \textit{for} en la línea 9 de la función \textit{IterarBottom} en la iteración $k$. Teniendo en cuenta el lema \ref{lemma_bottom}, este \textit{for} va a iterar sobre el conjunto formado por todos los subconjuntos $b$ consistentes de $D$ tal que $|b| = k$.  En el cuerpo de cada iteración de este \textit{for}, se evaluará si para cada uno de estos subconjuntos $b$, sucede que para todo conjunto en \textit{proximoBottom} $pb$ que sea superconjunto de $b$ sucede que $pb$ es inconsistente. En caso de ser esto verdadero se agrega $b$ a \textit{repairsChicos}. Veamos entonces que si $r$ es un \textit{repair} $r$ tal que $|r| = k$, entonces $r$ será  agregado a \textit{repairsChicos} en alguna iteracion de este \textit{for}.
Por absurdo asumamos que $r$ no se agrega. Hay solo dos razones posibles: o bien $r$ no está en \textit{bottom}, o bien $r$ está en \textit{bottom} pero no resulta verdadera la condición del \textit{if} en la línea 10.
Caso 1: $r$ no esta en \textit{bottom}. Absurdo, pues $r$ es un conjunto consistente y $|r| = k$.
Caso 2: $r$ está en \textit{bottom} pero la cláusula del \textit{if} en la linea 10 es falsa. Esto quiere decir que hay algún elemento en \textit{proximoBottom} $pb$ que es superconjunto de $r$ y $pb$ está marcado como consistente. Pero por lema \ref{finalizar_iteracion_8_proximo_bottom} $pb$ es un subconjunto consistente de $D$ con $|pb| = k + 1$. Por lo tanto, si la condición dio falsa, $pb$ es un superconjunto estricto de $r$, y $pb$ es consistente. Absurdo, pues $r$ es un \textit{repair}.

Teniendo en cuenta los dos absurdos, si $r$ es un \textit{repair} tal que $|r| = k$, $r$ será agregado a \textit{repairsChicos} en la iteración $k$. 
\end{proof}

\begin{lemma}\label{finalizar_iteracion_8_proximo_bottom}
Sea $k$ una iteración en la ejecución del algoritmo \textit{repairsFinder}. Entonces, al finalizar la línea 8 de la función \textit{IterarBottom}, si para un elemento $pb$ en \textit{proximoBottom} resulta que $pb.consistente$ es \textit{verdadero}, entonces $pb$ es un subconjunto consistente de $D$ y $|pb| = k +1$.
\end{lemma}

\begin{proof}
\underline{$pb$ es consistente}: vemos que en el \textit{for} que se ejecuta en la línea 2 de la función \textit{IterarBottom}, $pb$ fue marcado como consistente en solo dos casos: o bien $pb$ es un subconjunto de algún elemento en \textit{repairsGrandes}, o bien la llamada a la función \textit{chequearConsistencia(pb, $\Sigma$)} retornó \textit{true}. En el primer caso $pb$ es consistente, pues todos los elementos en \textit{repairsGrandes} son conjuntos consistentes, en el segundo caso, dado que la función \textit{chequearConsistencia} es correcta, $pb$ también es consistente.

\underline{$|pb| = k + 1$}: \textit{proximoBottom} se define en la línea 1 de la función \textit{IterarBottom} como el conjunto formado por todos los elementos de $nBottom + 1$ elementos, y sabemos que $nBottom = k$, pues $nBottom$ vale 1 en la iteración $k$ y $nBottom$ se incrementa en uno en cada iteración.

\underline{$pb \subset D$}: Trivialmente, \textit{proximoBottom} fue definido como un conjunto de subconjuntos de $D$.
\end{proof}



\begin{lemma}\label{lemma_bottom}
Sea $k$ una iteración en la ejecución del algoritmo \textit{repairsFinder}. Entonces al finalizar la línea 8 de la funcion \textit{IterarBottom} en esa iteración, el conjunto  \textit{bottom} consiste exactamente en todos los subconjuntos $b$ tal que $b \subset D$, $b$ consistente y $|b| = k$.
\end{lemma}

\begin{proof}
Ya vimos que todos los elementos en \textit{bottom} son subconjuntos de $D$. Veamos además que en cada iteración $k$ se cumple que al finalizar la línea 8 de la función \textit{IterarBottom} se cumple que $b$ es consistente y que $|b| = k$. Separamos en dos casos, $k=1$ y $k>1$.
\underline{Caso $k=1$}: \textit{bottom} se definió en la línea 4 del algoritmo como
todos los subconjuntos $b$ de $D$ tal que $|b| = 1$, y en la función \textit{InicializarBottom} se restringe \textit{bottom} a todos aquellos conjuntos $b$ que sean consistentes.

\underline{Caso $k>1$}: Notar que en este caso \textit{bottom} se definió en la iteración $k-1$ en la línea 14 de la función \textit{IterarBottom} como el conjunto de todos los elementos en \textit{proximoBottom} que estén marcados como consistentes. Veamos entonces que al momento de ejecutarse tal línea de la función, los elementos en \textit{proximoBottom} que están marcados como consistentes son exactamente todos los subconjuntos $pb$ de $D$ tales que $pb$ es consistente y $|pb| = k$. Veamos entonces las dos inclusiones, llamo subKCosistenes al conjunto definido por todos los subconjuntos consistes $s$ de $D$ tales que $|s| = k$ y llamo \textit{proximoBottomConsistenes} al conjunto de elementos que están en \textit{proximoBottom} marcados como consistentes al momento de ejecutarse la línea 14 de la función \textit{IterarBottom} en la iteración $k-1$.

\underline{$subKCosistenes \subseteq proximoBottomConsistentes$}: Notemos que \textit{proximoBottom} fue definido en la línea 1 de la misma función como el conjunto formado por todos los subconjuntos $pb \subset D$ tales que $|pb| = nBottom + 1$ y $pb$ no es superconjunto de ningún \textit{culprit}. Teniendo en cuenta que al momento de ejecutarse tal línea de la función la variable \textit{nBottom} vale $k$ para toda iteración $k$, resulta entonces trivial que en la iteración $k-1$, $nBottom + 1$ vale k y por lo tanto, después de ejecutada la línea 1, el conjunto \textit{proximoBottom} es exactamente el conjunto de todos los conjuntos $pb$ tales que $|pb| = k $ y $pb$ no es superconjunto de ningún \textit{culprit}. Dado que por el lema \ref{culprits_inconsistentes} todos los elementos en \textit{culprits} son inconsistentes, resulta que $s$ no puede ser superconjunto de algún \textit{culprit}, pues $s$ es consistente, por lo tanto $s$ está en \textit{proximoBottom} una vez ejecutada la línea 1 en la iteración $k-1$.
Notemos que por el lema \ref{for_proximo_bottom} una vez iterados todos los elementos $pb$ en el \textit{for} de al línea 2 de la función, todos aquellos elementos $pb$ serán marcados como consistentes si solo si son consistentes. Por lo tanto $s$ será marcado como consistente una vez finalizado tal \textit{for} y por lo tanto $s \in proximoBottomConsistentes$. 

\underline{$proximoBottomConsistentes \subseteq subKCosistenes$}: Sea entonces $pb$ un elemento en \textit{proximoBottom} marcado como consistente en la línea 14 de la función \textit{IterarBottom} en la iteración $k-1$. Ya vimos que $|pb| = k$, pues $nBottom + 1 = k$. Además por el lema \ref{for_proximo_bottom} dado que $pb$ fue marcado como consistente resulta que $pb$ es consistente. Por lo tanto $pn \in subKCosistenes$. 

\end{proof}


\begin{lemma}\label{for_proximo_bottom}
Una vez finalizado el \textit{for} de la línea 2 de la función \textit{IterarBottom}, todos los elementos en \textit{proximoBottom} son marcados como consistentes si solo si son consistentes.
\end{lemma}

\begin{proof}
Notemos que el \textit{for} de la línea 2 de la función \textit{IterarBottom} itera sobre todos los elementos en \textit{proximoBottom}. Sea entonces un elemento en $pb$ en \textit{proximoBottom} consistente. En caso de que sea subconjunto de algún elemento $rg$ en \textit{repairsGrandes} será marcado como consistente, lo cual es correcto pues todos los elementos en \textit{repairsGrandes} son consistentes.  En caso contrario se evaluará su consistencia por medio de la función \textit{chequearConsistencia}, que al ser correcta retornará \textit{verdadero}. En caso de que $pb$ sea inconsistente, $pb$ no puede ser subconjutno de ningun elemento en \textit{repairsGrandes}, y por lo tanto se evaluará consistencia por medio de la función \textit{chequearConsistencia}, que al ser correcta en este caso retornará \textit{falso}.  
\end{proof}

\begin{lemma}\label{maxima_cantidad_de_iteraciones}
La máxima cantidad de iteraciones que se puede ejecutar en el \textit{while} de \textit{repairsFinder} es $\parteEntera$.
\end{lemma}

\begin{proof}
\underline{Caso n impar:} En este caso $n = \parteEntera + 1 + \parteEntera$. Teniendo en cuenta que \textit{nBottom} se inicializa en 1, y que \textit{nTop} se inicializa en $n$, y notando que la primera se incrementa en cada iteración en una unidad, y que la segunda va decrementando a la misma velocidad que la primera, trivialmente la condición $nTop > nBottom$ será falsa solo cuando las dos variables valgan lo mismo, es decir cuando las dos valgan $\parteEntera + 1$, lo cual solo ocurrirá después de $\parteEntera$ iteraciones. 

\underline{Caso n par:} En este caso $n = \parteEntera + \parteEntera$. Con el mismo razonamiento que en el caso impar, la condición $nTop > nBottom$ será falsa solo cuando \textit{nTop} valga $\parteEntera$ y \textit{nBottom} valga $\parteEntera + 1$, lo cual solo ocurrirá después de $\parteEntera$ iteraciones. 

\end{proof}
















%% ...

\chapter{Implementación}

Tal como mencionamos en la introducción, parte de la motivación del presente trabajo es presentar una herramienta que acerque de manera \textit{amigable} el lenguaje \textit{Datalog +/-} al público general. De esta manera, por medio de una aplicación \textit{web} queremos proveer la funcionalidad de crear ontologías, así como también la posibilidad de ejecutar consultas sobre las mismas, siendo estas consultas tolerantes a las inconsistencias que pudieran existir en los datos almacenados sobre esas ontologías. 

En las páginas que siguen describiremos en detalle la implementación de esta herramienta. Cabe primero destacar que para construir nuestro sistema, hemos utilizado una herramienta ya existente, llamada \textit{IRIS}, que brinda la posibilidad de crear ontologías y ejecutar consultas en el lenguaje. Nos enfocaremos entonces en describir cuál es el alcance de \textit{IRIS}, detallando el límite entre las facilidades provistas por éste y las nuevas funcionalidades implementadas por nosotros. El código completo de este trabajo se puede encontrar en \url{https://github.com/pfromer/tesis/tree/new_refactor}.

\section{IRIS}

\textit{IRIS} es una herramienta \textit{open source} hecha en \textit{JAVA} que permite construir ontologías en \textit{Datalog +/-} y ejecutar consultas sobre las mismas. El código de \textit{IRIS} se encuentra publicado en \textit{Github} y se puede descargar desde \textit{https://github.com/NICTA/iris-reasoner}. De los elementos que provee el lenguaje, \textit{IRIS} brinda la posibilidad de definir \textit{TGDs}, \textit{hechos}, y \textit{consultas}. Existen otras herramientas que permiten definir ontologías en \textit{Datalog +/-} como \textit{vLog4J}, que también es \textit{open source} y \textit{VADALOG}, siendo este último propietario.

\subsection{Usabilidad}
Para utilizar \textit{IRIS} es necesario descargar el código de \textit{github}, instalar \textit{JAVA 8}, compilar el código en un archivo \textit{.jar}, y luego ejecutarlo. Al momento de ejecutar el archivo \textit{.jar} es necesario pasarle una serie de parámetros, entre ellos el \textit{path} a un archivo de texto que contiene el \textit{programa} a ejecutar, es decir que en este último se deben encontrar las \textit{TGDs}, los \textit{hechos} y las \textit{consultas}. Las respuestas a las \textit{consultas} son retornadas por \textit{IRIS} en \textit{standard output}. A grandes rasgos, podemos describir entonces a \textit{IRIS} como una aplicación de consola que puede procesar un \textit{programa} y devolver un resultado.

\begin{figure}[ht]
    \includegraphics[scale=0.45]{iris-console-application.png}
    \centering
    \caption{IRIS: aplicacion de consola}
    \label{fig:iris_console_application}
\end{figure}


\subsection{Sintaxis}\label{section_sintaxis}
La figura \ref{fig:iris_console_application} ejemplifica la sintaxis que deberá tener el input para poder ser procesado por \textit{IRIS}. En este input \textit{IRIS} puede identificar una base de conocimiento $(\Sigma_t, D)$ donde $\Sigma_t$ es un conjunto de \textit{TGDs} y $D$ es un conjunto de \textit{hechos}. En ese mismo archivo se podrán incluir un conjunto de consultas, cuyas respuestas serán retornadas por \textit{IRIS} en \textit{standard output}. Veamos ahora en detalle cuál es la sintaxis que debe respetar cada uno de los elementos del lenguaje.

\subsubsection{Constantes y Variables}
Las constantes se deben notar entre comillas simples y las variables deben ser antecedidas por el símbolo de interrogación \textit{?}.

\subsubsection{Átomos}
Los átomos constan de un nombre de predicado alfanumérico seguidos por un conjunto de argumentos encerrado entre paréntesis donde los argumentos están separados por coma. Cada argumento puede ser una constante o una variable.

\subsubsection{TGDs}
Para cada \textit{TGD} se debe separar la cabeza y el cuerpo intermediando la cadena \textit{``:-''}, ubicando la cabeza a la izquierda y el cuerpo a la derecha. La cabeza constará de un solo átomo mientras que el cuerpo contendrá un conjunto de átomos separados por coma. Se debe ubicar un punto final a la derecha de cada \textit{TGD}. Las variables que se encuentren en la cabeza y no se encuentren en ningún átomo del cuerpo serán consideradas por \textit{IRIS} como \textit{nulos}.   El siguiente ejemplo muestra una \textit{TGD} que podrá ser correctamente procesada por \textit{IRIS}.

\begin{center}
    q(?x, ?y, ?z) :- p1(?x, ?y), p2('a').
\end{center} 

\subsubsection{Hechos}
Los hechos constan de un solo átomo en donde todos los argumentos son constantes. Cada hecho debe finalizar con un punto a la derecha.

\subsubsection{Consultas}\label{consultas_iris}
Las consultas deben ser precedidas por la cadena \textit{``?-''} y seguidas por un conjunto de átomos separados por coma, en donde los argumentos de cada átomo pueden ser tanto variables como constantes. Ejemplificamos ahora con la siguiente consulta:

\begin{center}
    ?- p1(?x, 'a'), p2(?z).
\end{center} 

Es importante mencionar que \textit{IRIS} no permite cuantificar existencialmente las variables en las consultas. De esta manera, para que la respuesta no sea vacía, todo el cuerpo de la consulta deberá mapear homomórficamente con un conjunto de átomos en el \textit{chase} que computará \textit{IRIS}, donde todos esos átomos del \textit{chase} deberán exclusivamente contener constantes en sus argumentos.

\section{Extendiendo IRIS}
Con el objetivo final de alcanzar \textit{Datalog +/-} al usuario general, y queriendo ofrecer a la vez la posibilidad de responder consultas bajo ambientes inconsistentes, hemos extendido a \textit{IRIS} con tres nuevas funcionalidades:

\begin{itemize}
    \item Nueva \textit{api} de manera que \textit{IRIS} pueda ser consultada a través de la \textit{web}.
    \item Nuevo módulo de manejo de inconsistencia de manera que \textit{IRIS} pueda responder consultas bajo las semánticas \textit{AR} e \textit{IAR}.
    \item Posibilidad de cuantificar existencialmente las variables en las conusltas.
\end{itemize}

Detallaremos ahora nuestra implementación para cada una de estas funcionalidades.

\subsection{Api Web}

Para que \textit{IRIS} pueda ser consultada a través de la \textit{web}, necesitamos exponer una \textit{api} pública, con una interfaz clara, que le permita al usuario definir un \textit{programa}, donde se puedan especificar \textit{restricciones de integridad}, \textit{tgds}, \textit{hechos}, \textit{consultas}; y donde se pueda además especificar bajo cual \textit{semántica} se quiere ejecutar a esas \textit{consultas}.

Para poder responder las consultas, la implementación de esta \textit{api} accederá a los otros módulos implementados en el mismo servidor,  entre los cuales se encuentra \textit{IRIS} y otro módulos de implementación propia.

\begin{figure}[ht]
    \includegraphics[scale=0.45]{Server_Client_Iris_2.png}
    \centering
    \caption{Cliente - Servidor}
    \label{fig:server_client}
\end{figure}

La figura \ref{fig:server_client} muestra la arquitectura general del nuevo sistema \textit{web}. La nueva \textit{api} está expuesta en un servidor que recibe peticiones de clientes. El módulo \textit{Api Web} solo es encargado de parsear el input recibido en formato \textit{Json}, enviarle la consulta al \textit{Módulo de Semánticas}, esperar su respuesta y devolverla al cliente otra vez en el formato \textit{Json}. Cabe aclarar que todas las comunicaciones entre los módulos \textit{Api Web}, \textit{Módulo de Semanticas}, \textit{Módulo de Repairs} y \textit{IRIS} ocurren en un mismo proceso dentro del servidor a través de llamadas a funciones implementadas en \textit{JAVA} dentro de esos módulos. De esta forma podemos ver al módulo \textit{Api Web} como un mero intermediario entre las llamadas \textit{web} de los clientes y los demás módulos del servidor que se encargan en su conjunto de procesar las consultas.

Veamos ahora cuáles son los \textit{endpoints} que expone nuestra \textit{api}, y cómo 
deben ser los \textit{requests} junto con sus respuestas. La implementación de estos \textit{endpoints} se puede encontrar en \url{https://github.com/pfromer/tesis/tree/new_refactor/eclipse-workspace/iris-web/src/api}. 

\subsubsection{Query Endpoint}\label{query_enpoint_section}

Este \textit{endpoint} permite realizar \textit{consultas} para un conjunto de \textit{Restricciones de Integridad}, \textit{TGDs} y \textit{hechos}. En la figura \ref{fig:query_endpoint} se muestra en un ejemplo el formato esperado para el \textit{body} que deben tener los \textit{request} de este \textit{endpoint}.

\underline{Endpoint Url:} http://[url\_base]/iris/query\footnote{Se hará un \textit{deploy} de esta \textit{api} en los servidores de la facultad paro no se han definido aún las rutas.}.

\underline{Http Method:} Post.


\begin{figure}[ht]
    \includegraphics[scale=0.8]{query_endpoint.PNG}
    \centering
    \caption{Formato esperado para una petición al Query Endpoint}
    \label{fig:query_endpoint}
\end{figure}


Tal como se ejemplifica en la figura \ref{fig:query_endpoint}, el campo \textit{ncs} es un arreglo en el que cada elemento debe ser un \textit{Json} con el que campo \textit{body} que consta de una serie de átomos separados por coma donde cada átomo debe seguir la sintaxis tal como se especificó en la sección \ref{section_sintaxis}. Cada uno de esos elementos será interpretado como el cuerpo de una \textit{Restricción de Integridad}, donde las comas que separan cada átomo representan conjunción.

De manera similar, el campo \textit{tgds} es también un arreglo de objetos \textit{Json} donde cada elemento debe contener los valores \textit{head} y \textit{body}.  En el campo \textit{head} se debe incluir un solo átomo y en el campo \textit{body} una secuencia de átomos separados por coma. En cuanto al campo \textit{facts}, cada elemento en el arreglo será un objeto con un único campo \textit{value} que deberá contener un solo átomo con parámetros constantes.

Con respecto al campo \textit{queries}, cada elemento en el arreglo deberá ser un \textit{Json} de dos campos, donde el campo \textit{showInOuput} es un arreglo con las variables cuyos mapeos en el \textit{chase} deberán mostrarse en el \textit{output} de la consulta y donde el campo \textit{body} es el cuerpo de la consulta en sí. Notar que las variables que aparezcan en el cuerpo de la consulta y no se incluyan en el arreglo del campo \textit{showInOutput} son justamente las variables que queremos cuantificar existencialmente. En el caso en el que este arreglo sea un arreglo vacío, estaremos en el caso en el que todas las variables se deberán cuantificar existencialmente, siendo la consulta una \textit{consulta conjuntiva booleana} tal como se la detalló en la sección \ref{seccion_datalog}.
    
Con respecto al campo \textit{semantics}, este podrá contener alguno de los siguientes tres valores: \textit{standard}, \textit{AR} o \textit{IAR}. En el caso en que se especifique \textit{standard}, las consultas se ejecutarán bajo la semántica detallada en la sección \ref{consultas_bajo_tgds}, es decir sin manejo de inconsistencia, lo cual podrá ocurrir solo cuando todas las \textit{restricciones de integridad} se cumplan para ese conjunto de \textit{TGDs} y de \textit{hechos}. En caso contrario se le avisará al cliente que las consultas no se pueden responder bajo esa semántica, dado que no se cumplen todas las restricciones, indicándose a la vez cuáles son aquellas que no se cumplen.

El campo \textit{$max\_depth$} indicará hasta cuantas iteraciones en el algoritmo del \textit{chase} el \textit{cliente} está dispuesto a esperar. Si el valor de este campo es \textit{null} entonces no habrá un máximo de iteraciones definido y se seguirá ejecutando hasta que finalice la construcción del \textit{chase} o bien hasta que ocurra un \textit{timeout}. El valor del \textit{timeout} será un valor fijo definido en la configuración del servidor.

En la figura \ref{fig:query_endpoint_answer_2} se puede ver un ejemplo de respuesta de este \textit{endpoint} para el caso en el que en la petición del cliente el valor del campo \textit{semantics} fue \textit{standard} pero no se cumplieron algunas de las \textit{restricciones de integridad} pasadas en el campo \textit{ncs}. Vemos que en la respuesta, el campo \textit{unsatisfied} es un arreglo donde se indican los índices de las \textit{restricciones de integridad} que no fueron satisfechas en el arreglo de \textit{ncs} que el cliente envió en la petición. 


\begin{figure}[ht]
    \includegraphics[scale=0.8]{unsatisfied.PNG}
    \centering
    \caption{Ejemplo de respuesta del Query Endpoint}
    \label{fig:query_endpoint_answer_2}
\end{figure}


En al figura \ref{fig:query_endpoint_answer_1} se muestra un ejemplo de respuesta para una petición de un cliente que se encontró en alguno de estos dos casos:

\begin{itemize}
    \item El valor del campo \textit{semantics} es \textit{AR} o \textit{IAR}
    \item El valor del campo \textit{semantics} es \textit{standard} y se cumplen todas las \textit{restricciones de integridad}.
\end{itemize}

En este caso la \textit{api} devolverá un arreglo de respuestas que estará ordenado en el mismo orden en el que se encuentren sus respectivas consultas en la petición del cliente.

\begin{figure}[ht]
    \includegraphics[scale=0.8]{answers.PNG}
    \centering
    \caption{Ejemplo de respuesta del Query Endpoint}
    \label{fig:query_endpoint_answer_1}
\end{figure}

En el caso en el que el servidor no logre procesar la consulta antes del tiempo definido en la configuración del \textit{tiemout}, la \textit{api} responderá como se muestra en la figura \ref{fig:query_endpoint_answer_timeout}. 

\begin{figure}[ht]
    \includegraphics[scale=0.8]{error_timeout.PNG}
    \centering
    \caption{Respuesta con error de \textit{timeout}}
    \label{fig:query_endpoint_answer_timeout}
\end{figure}

\subsubsection{Repairs Endpoint}

Hemos agregado además un endpoint que dado un conjunto de \textit{restricciones}, \textit{TGDs} y \textit{hechos}, retorna el conjunto de \textit{repairs}. La figura \ref{fig:repairs_endpoint} muestra con un ejemplo el formato esperado que deben tener las peticiones a este \textit{Repairs Endpoint}.

\underline{Endpoint Url:} http://[url\_base]/iris/repairs\_finder.

\underline{Http Method:} Get.

\begin{figure}[ht]
    \includegraphics[scale=0.8]{repairs_endpoint.PNG}
    \centering
    \caption{Formato esperado para una petición al Repairs Endpoint}
    \label{fig:repairs_endpoint}
\end{figure}

En la figura \ref{fig:repairs_endpoint_answer} se muestra un ejemplo de respuesta para el \textit{Repairs Endpoint}.
\begin{figure}[ht]
    \includegraphics[scale=0.8]{repairs_endpoint_answer.PNG}
    \centering
    \caption{Ejemplo de respuesta del Repairs Endpoint}
    \label{fig:repairs_endpoint_answer}
\end{figure}
\subsection{Módulo de Semánticas}

Veamos ahora en detalle cuál es la responsabilidad del \textit{Módulo de Semánticas} y cómo está implementado. Veamos primero que la interfaz que expone este módulo consta de un sólo método al que llamamos \textit{Execute}. Este método recibe un objeto \textit{executeParams}, el cual es una instancia de una clase \textit{JAVA} que contiene los mismos campos que se especificaron en el \textit{Json} de la figura \ref{fig:query_endpoint}, es decir las \textit{restricciones de integridad}, las \textit{TGDs}, los \textit{hechos}, las \textit{consultas} y la \textit{semántica} bajo la cual se desea ejecutar las consultas.

Dependiendo del valor en el campo \textit{semantics}, el método \textit{Execute} hará una llamada a alguno de estos tres métodos privados: \textit{ExecuteStandard}, \textit{ExecuteAR}, o \textit{ExeciteIAR}. Veamos entonces cómo están implementados cada uno de estos tres métodos.

\subsubsection{Método ExecuteStandard}


Este método debe primero evaluar si las \textit{restricciones de integridad} son satisfechas por las \textit{TGDs} y los \textit{hechos}. Para poder determinar lo anterior, consultará al módulo de \textit{IRIS}, generando un nuevo \textit{programa}, con la sintaxis especificada en la sección \ref{section_sintaxis}, en las que los \textit{hechos} y las \textit{TGDs} son las que recibió por parámetro, mientras que las \textit{consultas} serán consultas conjuntivas \textit{booleanas} en las que el cuerpo de cada consulta será el cuerpo de cada \textit{restricción de integridad}. 

Si el módulo de \textit{IRIS} devolviera \textit{true} para alguna de esas consultas, entonces determinamos que la \textit{restricción} relacionada a esa consulta es violada por las \textit{TGDs} y los \textit{hechos}. El método indicará en su respuesta cuales son aquellas restricciones que no fueron satisfechas, entendiéndose así que es imposible ejecutar las \textit{consultas} que se han requerido bajo esta semántica.

En el caso en el que ninguna de las restricciones fueran violadas, entonces este método enviará un nuevo \textit{programa} a \textit{IRIS}, con las mismas \textit{TGDs} y \textit{hechos} que en la llamada anterior pero ahora sí con las consultas que el cliente desea ejecutar. Para cada consulta se instanciará una respuesta, donde la respuesta puede ser o bien un valor \textit{booleano} (en caso de que la consulta haya sido \textit{booleana}) o bien una matriz, representando las filas y las columnas de la respuesta, donde cada columna se corresponderá con cada una de las variables en el arreglo \textit{showInOutput} que se especificó para esa consulta.

La implementación de este módulo se puede encontrar en \url{https://github.com/pfromer/tesis/tree/new_refactor/IRIS%2B-/src/org/deri/iris/semantic_executor}.

\subsubsection{Método ExecuteAR}

Este método ejecutará las consultas bajo la semántica \textit{AR}. Para ello deberá conocer primero el conjunto de \textit{repairs} correspondientes a esas \textit{restricciones}, \textit{TGDs} y \textit{hechos}, el cual lo obtendrá por medio del \textit{Módulo de Repairs}, sobre el cual detallaremos su implementación más adelante. 

Una vez obtenido el conjunto de \textit{repairs}, el método \textit{ExecuteAR} procederá de la siguiente manera: para cada \textit{repair} armará un nuevo \textit{programa} en el que los \textit{hechos} serán los mismos \textit{hechos} que se encuentren en ese \textit{repair}. Para cada \textit{programa}, las \textit{consultas} y las \textit{TGDs} serán siempre las mismas, es decir las que el método recibió por parámetro. Una vez enviados a ejecutar todos los programas al módulo de \textit{IRIS}, se computará la intersección de las respuestas para cada consulta, en donde esta intersección consistirá en una intersección de matrices para el caso de las consultas no \textit{booleanas} y en una conjunción lógica en el caso contrario.

\subsubsection{Método ExecuteIAR}

Ejecutaremos en este caso a las consultas bajo la semántica \textit{IAR}. Al igual que en el caso anterior, el método \textit{ExecuteIAR} obtendrá el conjunto de \textit{repairs} por medio del \textit{Módulo de Repairs}. Luego computará la intersección de los \textit{repairs} y armará un solo \textit{programa} en el que los \textit{hechos} serán la intersección obtenida, mientras que las \textit{TGDs} y las \textit{consultas} serán las mismas que recibió por parámetro. La respuesta se armará de igual manera que en el caso en el que ninguna \textit{restricción} fuera violada en el método  \textit{ExecuteStandard}.

\subsection{Módulo de Repairs}\label{modulo_de_repairs}

Este módulo es una implementación hecha en \textit{JAVA} del algoritmo \textit{RepairsFinder} presentado en la sección \ref{repairs_finder_section}. El código completo de esta implementación se puede ver en \url{https://github.com/pfromer/tesis/blob/new_refactor/IRIS%2B-/src/org/deri/iris/repairs_finder/RepairsFinder.java}.

Si bien nuestro objetivo en esta ocasión es encontrar conjuntos maximales \textit{consistentes}, cabe mencionar aquí que esta implementación puede ser fácilmente reutilizable para encontrar conjuntos maximales con respecto a otras características más allá de consistencia. Esto se debe a que los únicos parámetros que recibe esta implementación son el conjunto de \textit{hechos} más una función que debe poder recibir un subconjunto de esos hechos y devolverá un booleano indicando si aquella propiedad para la cual se desea encontrar conjuntos maximales se cumple o no para ese subconjunto. En este caso la función que le pasamos por parámetro al \textit{Modulo de Repairs} es una función que dado un conjunto de \textit{hechos} llamará al módulo de \textit{IRIS} para un conjunto de \textit{restricciones} y \textit{TGDs} fijas, con el objetivo de saber si aquellas \textit{restricciones} se sastisfacen para esas \textit{TGDs} y ese subconjunto de \textit{hechos}. De esta manera el \textit{Módulo de Repairs} desconoce totalmente a \textit{IRIS}, ya que solo ejecuta la función recibida por parámetro sin conocer la implementación de dicha función\footnote{Teniendo en cuenta esta aclaración cabe mencionar que los métodos \textit{ExecuteAr} y \textit{ExecuteIAR} deben ser capaces de instanciar esta función y pasarla por parámetro al \textit{Módulo de Repairs.}}.

Teniendo en cuenta que el algoritmo necesita computar reiteradas veces inclusión entre dos conjuntos, vale destacar que implementamos esta funcionalidad numerando a todos los \textit{hechos} y manteniéndolos ordenado en todo momento. De esta manera, dado que todo subconjunto de \textit{hechos} será una lista ordenada de esos hechos, computar inclusión entre estos dos conjuntos se hará a lo sumo en \textit{n} pasos, donde \textit{n} es el tamaño del conjunto más pequeño. La implementación de inclusión entre conjuntos se puede ver en el método \textit{isSubSetOf} en la clase \textit{AboxSubSet} en el siguiente link: \url{https://github.com/pfromer/tesis/blob/new_refactor/IRIS%2B-/src/org/deri/iris/repairs_finder/AboxSubSet.java}.

\subsection{Consultas con cuantificadores existenciales}

Como mencionamos en la sección \ref{consultas_iris}, \textit{IRIS} no posee la capacidad de responder consultas en las que se cuantifique existencialmente a las variables de la forma $Q(\textbf{X}) = \exists\textbf{Y}\Phi(\textbf{X},\textbf{Y})$, ni tampoco consultas conjuntivas \textit{booleanas} de la forma $Q() = \exists\textbf{Y}\exists\textbf{Y}\Phi(\textbf{X},\textbf{Y})$. En efecto \textit{IRIS} solo puede responder consultas del tipo $Q(\textbf{X},\textbf{Y}) = \Phi(\textbf{X},\textbf{Y})$. 

Veamos entonces cuales fueron las modificaciones que hemos añadido de manera que \textit{IRIS} pueda responder todos los tipos de consultas ejemplificadas. Tengamos en cuenta que las variables que se cuantifiquen existencialmente podrán mapear tanto a constantes como a \textit{nulos frescos} en el \textit{chase}. De esta manera las modificaciones que hicimos consistieron primero en que al momento de evaluar la consulta, buscando átomos en el \textit{chase} que mapearan \textit{homomórficamente}   con el cuerpo de la misma, \textit{IRIS} dejara de descartar necesariamente los \textit{átomos} que tuvieran \textit{nulos}. De esta manera, el método original \textit{evaluateQuery} en la clase \textit{StratifiedBottomUpEvaluationStrategy} fue modificado para que al evaluar una consulta pueda devolver tuplas en las que no necesariamente todas las posiciones contengan constantes sino también \textit{nulos frescos}.

Una vez hecho este cambio agregamos una capa intermedia\footnote{ver código fuente de esta capa en la clase \textit{QueryResult}.} que toma la lista de tuplas retornadas por la nueva versión del método \textit{evaluateQuery} y solo se queda con aquellas columnas que figuran en el arreglo \textit{showInOutput} que describimos en la sección \ref{query_enpoint_section}. Una vez filtradas las columnas descartamos ahora sí a todas aquellas filas que contengan tuplas con elementos \textit{nulos}, pues solo puede haber \textit{nulos} en las columnas correspondientes a aquellas variables que se quieren cuantificar existencialmente, y justamente esas son las columnas que descartamos en el paso anterior, pues son las que no figuran en el arreglo \textit{showInOutput}. Notar que de esta manera la respuesta final solo contiene tuplas con valores constantes.

Cabe mencionar que para el caso de las consultas conjuntivas \textit{booleanas} la nueva capa intermedia no retornará ahora una lista de tuplas, sino que devolverá un valor booleano, siendo este \textit{verdadero} solo cuando el resultado devuelto por el método \textit{evaluateQuery} sea una lista de tuplas no vacía.

\subsection{Profundidad máxima en el chase}

Es importante mencionar que la propiedad \textit{Bounded guard-depth property} para el fragmento \textit{Guarded} tiene el valor de determinar una cota en la cantidad de iteraciones que se deberán ejecutar para computar las consultas pero que lamentablemente a fines prácticos termina siendo demasiado alta. Lo interesante de esta propiedad es que fija la cantidad de iteraciones para un determinado esquema $R$, lo cual hace que esta cota sea independiente de la cantidad de datos. Pero cuando intentamos implementar esta propiedad, que vale aclarar no está implementada en  \textit{IRIS}, notamos que los valores de estas cotas resultaban extremadamente altos, aún para programas pequeños. 

A modo de ejemplo, el valor de $\delta$, tal como se describe en la sección \ref{guarded_forest_subsection} es de $8.589934592E9$ para el siguiente \textit{programa}:

\begin{figure}[ht]
    \includegraphics[scale=0.5]{programa_cota_alta.PNG}
    \centering
    \label{fig:programa_cota_alta}
\end{figure}

Por tal motivo el servidor implementa un \textit{timeout} como así también la posibilidad de que el cliente le pueda indicar la máxima cantidad de iteraciones que está dispuesto a esperar a través del campo \textit{$max\_depth$} como se mostró en la figura \ref{fig:query_endpoint}.  

\section{Cliente Web}

Nos enfocaremos ahora en detallar la funcionalidad de nuestro \textit{cliente}, el cual está conformado por una sola página \textit{web} que brindará al usuario la posibilidad de ejecutar consultas al servidor de manera sencilla. En la figura \ref{fig:cliente_web_2} se puede ver una captura de pantalla de tal página. Durante el resto de esta sección describiremos el comportamiento de cada uno de los componentes que se muestran en la captura, así como su implementación.

Dicha implementación se puede encontrar en \url{https://github.com/pfromer/tesis/tree/new_refactor/NodeProject/src}.

\subsection{Parser en el cliente}

Tal como se muestra en la figura \ref{fig:cliente_web_2}, en la pantalla del \textit{cliente} se muestran dos editores de texto. El contenido de estos dos editores puede ser o bien ingresado por el usuario o bien cargado desde un archivo de texto almacenado en al computadora del cliente, solo después de que el usuario haya hecho \textit{click} en el botón \textit{Load Program}. En el editor izquierdo se deberán ingresar las \textit{restricciones}, \textit{claves}, \textit{tgds} y \textit{hechos}, y en el derecho las \textit{consultas}. Si el texto hubiera sido ingresado a través de la carga de un archivo, el \textit{cliente} se encargará de mostrar las \textit{consultas} que hubiere en ese archivo en el editor derecho, separándolas de los demás elementos que se mostrarán en el editor \textit{izquierdo}. 

\begin{figure}[ht]
    \includegraphics[scale=0.5]{cliente_web_2.PNG}
    \centering
    \caption{Cliente Web}
    \label{fig:cliente_web_2}
\end{figure}

 
Para poder hacer esta separación, el \textit{cliente} cuenta con un parser propio, el cual, a través de una serie de \textit{expresiones regulares}\footnote{La implementación de estas expresiones regulares se encuentra en el archivo \textit{regexService}.}  estará encargado de \textit{parsear} los textos ingresados en los editores, detectar posibles errores de sintaxis, y luego instanciar nuestros objetos en \textit{Javascript} los cuales representarán cada uno de los elementos ingresados. Hablaremos sobre estos objetos en la sección \ref{objetos_javascript}, pero detallaremos primero cuál es la sintaxis esperada por nuestro \textit{parser}.

\subsection{Sintaxis}

El hecho de que el cliente posea su propio \textit{parser} brinda la posibilidad no solo de detectar errores sintácticos antes de que las consultas sean enviadas al servidor, sino de también definir una sintaxis propia, no necesariamente igual a la que se mostró en la sección \ref{section_sintaxis}, la cual deberemos respetar de todos modos al momento de generar el \textit{input} para \textit{IRIS}. Hemos mantenido de todas maneras en gran medida aquella sintaxis, pues las variables, constantes, átomos y \textit{hechos} mantendrán el mismo formato. Nos enfocaremos entonces en los elementos que han cambiado su formato esperado, como las \textit{tgds} y las \textit{consultas}, así como también en aquellos nuevos elementos desconocidos por \textit{IRIS}, como las \textit{restricciones de integridad} y las \textit{claves}.

\subsubsection{TGDs}

Las \textit{TGDs} deberán respetar el siguiente formato: la \textit{cabeza} y el \textit{cuerpo} no se encontrarán separadas por la cadena ``:-'', sino por la cadena ``->''; además la \textit{cabeza} no se encontrará a la izquierda y el \textit{cuerpo} a la derecha, sino al revés. El siguiente es un ejemplo válido de una \textit{TGD} para nuestro cliente.

\begin{center}
 \textit{sabeProgramarEn(?x, ?y), lenguajeFront(?x) ->  frontDeveloper(?y).}
\end{center}

\subsubsection{Consultas}

La sintaxis de las consultas deberá poder diferenciar aquellas variables que se quieran cuantificar existencialmente de aquellas que no. De esta manera se separará el cuerpo de la consulta de una lista de variables que no se quiere cuantificar existencialmente. Estas lista de variables se encontrarán encerradas por paréntesis, y cada una de ellas separadas por coma. El cuerpo de la consulta se encontrará a la derecha de la cadena ``:-'' tal como se muestra en el siguiente ejemplo:

\begin{center}
 \textit{(?x) :- sabeProgramarEn(?x, ?y), lenguajeFront(?x).}
\end{center}

\subsubsection{Restricciones de integridad}

Las \textit{restricciones} deberán respetar el siguiente formato: se deberá mostrar el cuerpo, seguido de la cadena ``->'', seguido de o bien el caracter $\bot$, o bien la cadena \textit{``bottom''}. Los siguientes son ejemplos correctos de \textit{restricciones} en la sintaxis de nuestro cliente:

\begin{itemize}
    \item \textit{sabeProgramarEn(?x, 'pedro') -> $\bot$.}
    \item \textit{casadoCon(?x, ?y), soltero(?y) -> bottom.}
\end{itemize}

\subsubsection{Claves}

Las \textit{claves} se notarán siempre con la la letra \textit{k} seguida del nombre del predicado sobre el cual se quiere definir la \textit{clave} y un arreglo con los números de posiciones que definirán la clave. El nombre del predicado y el arreglo se encierran entre paréntesis. En el siguiente ejemplo se define que las posiciones de parámetro 1 y 3 son una clave sobre el predicado \textit{p}.

\begin{center}
 \textit{k(p[1,3]).}
\end{center}

\subsection{Objetos del modelo}\label{objetos_javascript}

Tal como comentamos en la sección anterior, por medio de las expresiones regulares definidas en nuestro \textit{cliente}, iremos identificando los elementos del \textit{programa} introducidos en los editores y en base a esto instanciaremos objetos que representarán a cada uno de aquellos elementos. De esta manera hemos implementado un \textit{builder} para cada tipo de elemento del lenguaje, es decir un \textit{builder} para las \textit{TGDs}, otro para las \textit{consultas} y lo mismo para las \textit{restricciones de integridad}, \textit{claves} y \textit{hechos}. De esta forma, en base a la expresión regular que haga \textit{match} con cada línea del texto ingresado en el editor, nuestro parser sabrá a cual \textit{builder} llamar, y le pasará por parámetro la línea de texto correspondiente. Así, cada \textit{builder} debe implementar el método \textit{build(line)} en donde \textit{line} es una línea de texto ingresada en el editor que cumple con el formato esperado por ese \textit{builder}. Cómo ejemplo, el \textit{tgdBuilder} espera que \textit{line} sea una línea de texto que cumpla con el formato especificado para las \textit{TGDs} en la sección anterior.

Cada uno de los objetos devueltos por el método \textit{build(line)} de nuestros \textit{builders} implementará una serie de métodos concernientes al elemento del lenguaje que esté representando. Por ejemplo el objeto construido por el \textit{tgdBuilder} implementa el método \textit{isGuarded}, que retornará \textit{true} solo cuando la \textit{TGD} en cuestión pertenezca al fragmento \textit{guarded}.

Para ver la implementación completa de estos \textit{builders} ver carpeta \textit{builders} en el apéndice.

\subsection{Método toJson}\label{metodo_tojson}

En particular, cada uno de esos objetos deberá implementar el método \textit{toJson()}, lo cual permitirá que podamos construir el \textit{json} que enviaremos al servidor. Dicho \textit{json} deberá cumplir el formato mostrado en la figura \ref{fig:query_endpoint}. De esta manera, al momento en el que el usuario haga \textit{click} en el botón \textit{Execute Queries}, se construirá un objeto \textit{json}, en base a ir llamando al método \textit{toJson()} de cada uno de los objetos anteriores.

Veamos ahora algunos ejemplos del resultado esperado por el método toJson().

\begin{exmp}
Sea \textit{tgdObj} el resultado de ejecutar:

\begin{center}
   \textit{tgdBuilder.build(``sabeProgramarEn(?x, ?y), lenguajeFront(?x) ->  frontDeveloper(?y).'')} 
\end{center}

Entonces, al ejecutar el método \textit{tgdObj.toJson()} obtendremos el siguiente \textit{json} como resultado:


\begin{figure}[ht]
    \includegraphics[scale=0.8]{tgd_json.PNG}
    \centering
\end{figure}


el cual será agregado al campo \textit{TGDs} del \textit{json} presentado en la figura \ref{fig:query_endpoint}.

\end{exmp}

\begin{exmp}
Sea \textit{queryObj} el resultado de ejecutar:

\begin{center}
   \textit{queryBuilder.build(``(?x) :- frontDeveloper(?x)'')} 
\end{center}

Entonces, al ejecutar el método \textit{queryObj.toJson()} obtendremos el siguiente \textit{json} como resultado:


\begin{figure}[ht]
    \includegraphics[scale=0.8]{query_json.PNG}
    \centering
\end{figure}
\end{exmp}

Especial atención requiere la implementación del método \textit{toJson()} en los objetos devueltos por el \textit{keyBuilder}. Recordemos que las \textit{claves} no son parte de la interfaz de nuestra \textit{Api Web} y que \textit{IRIS} no implementa \textit{claves}, pero teniendo en cuenta que nuestra \textit{api} implementa \textit{restricciones de integridad} podemos entonces reescribir las \textit{claves} como tales \textit{restricciones}. Veremos en la próxima sección que nuestro \textit{cliente} solo hará tal reescritura cuando las \textit{claves} sean \textit{no conflictivas}, tal como se las describió en la sección \ref{claves_no_conflictivas}. 

\begin{exmp}
Sea \textit{p} un predicado ternario y sea \textit{keyObj} el resultado de ejecutar:

\begin{center}
   \textit{queryBuilder.build(``k(p[1])'')} 
\end{center}

En este caso estamos diciendo que dadas dos instancias de \textit{p}, a igual valor del primer parámetro en cada instancia, necesariamente no podrá ocurrir que cada una de las instancias tenga una constante diferente en el segundo parámetro, y lo mismo para el tercer parámetro. Asumiendo que esta \textit{clave} es no conflictiva con todas las \textit{TGDs} del  \textit{programa}, podemos decir que esta \textit{clave} se cumplirá solo cuando ninguna de las dos siguientes \textit{restricciones} fallen:


\begin{itemize}
    \item \textit{$p(x, y_1, z_1), p(x, y_2, z_2), y_1 \neq y_2 \rightarrow \bot$.}
    \item \textit{$p(x, y_1, z_1), p(x, y_2, z_2), z_1 \neq z_2 \rightarrow  \bot$.}
\end{itemize}

Por lo tanto, en este caso el resultado de ejecutar \textit{keyObj.toJson()} será un arreglo representando ambas \textit{restricciones}:

\begin{figure}[ht]
    \includegraphics[scale=0.8]{key_obj_json.PNG}
    \centering
\end{figure}
\end{exmp}

Veremos más adelante que el cliente mantendrá un \textit{mapa} que indicará para toda \textit{restricción} enviada al servidor a cual número de línea en el \textit{programa} corresponde esa restricción, pudiendo ser esa línea en el programa una \textit{restricción} o bien una \textit{clave}. De esta manera el \textit{cliente} podrá indicarle al usuario cuáles fueron aquellas \textit{claves} o \textit{restricciones} que no se satisfacen en el \textit{programa} ingresado.

\subsection{Validación de claves no conflictivas}
Tal como mencionamos, el \textit{cliente} hará una validación de las \textit{claves} ingresadas en el programa, y en el caso en el que alguna clave ingresada no fuera \textit{no conflictiva}, se le avisará al usuario que ese tipo de \textit{claves} no son soportadas por el sistema. Para poder hacer este chequeo, todos los objetos instanciados en el cliente que representan las \textit{claves} del programa implementan el método \textit{isNonConflicting(tgd)}, cuya implementación cumple con la definición de no conflictividad presentada en la sección \ref{claves_no_conflictivas}: 

\begin{lstlisting}[caption=Implementación de claves no conflictivas]
isNonConflicting : function(tgd){
					return this.predicate != tgd.head.predicate.name ||
						(!this.keyPositions.isProperSubsetOf(tgd.xPositionsInHead()) && tgd.allNullsAppearOnlyOnceInTheHead());
					}
\end{lstlisting}

En el mismo sentido, el objeto que representa el \textit{programa} completo, definirá si una \textit{key} es no conflictiva utilizando la implementación de no conflictividad anterior:

\begin{lstlisting}[caption=Implementación de claves no conflictivas]
isNonConflicting: function(key){
	return this.tgds.every(tgd => key.isNonConflicting(tgd));
}
\end{lstlisting}

Para entender la implementación de esta funcionalidad en su totalidad será necesario desde ya entender el comportamiento de todas las propiedades y métodos que se invocan desde la función \textit{isNonConflicting}, cuyas implementaciones se encuentran en el apéndice en los archivos \textit{tgdBuilder}, \textit{keyBuilder} y \textit{arrayPrototype}. Creemos de todas maneras que los nombres de estos métodos y propiedades son lo suficientemente descriptivos como para que el lector pueda imaginar su comportamiento sin necesidad de leer el código completo.

\subsection{Experiencia de usuario}

Enumeraremos ahora todas las funcionalidades brindadas por nuestro cliente, detallando como será la \textit{experiencia del usuario} en cada caso.

\subsubsection{Errores de sintaxis}
Los errores sintácticos se mostrarán en rojo en el editor. Cuando el usuario intente ejecutar una consulta sobre un \textit{programa} que tenga errores sintácticos, se le mostrará una alerta avisándole que debe corregir dichos errores. Esta implementación se encuentra en nuestra clase \textit{Editor} que captura todos los eventos que suceden en los editores. Para cada uno de estos eventos, la clase validará los cambios contra todas nuestras expresiones regulares; de esta manera toda línea en el editor que no haga \textit{match} con ninguna expresión será marcada en rojo, tal como se muestra en la siguiente pantalla: 

\begin{figure}[ht]
    \includegraphics[scale=0.5]{cliente_web_syntax_error.PNG}
    \centering
    \caption{Error de sintaxis}
    \label{fig:cliente_web_syntax_error}
\end{figure}

\subsubsection{Validación de fragmento}
El usuario podrá validar también el fragmento de \textit{Datalog +/-} al que pertenece el programa ingresado. Al hacer \textit{click} en el botón \textit{Check Datalog Fragment}, aparecerá un cartel en pantalla indicando cual es el fragmento. Tal funcionalidad se pudo lograr gracias a la implementación del método \textit{fragment()} en los objetos devueltos por la clase \textit{tgdBuilder}. Esto quiere decir que cada objeto \textit{tgd} instanciado en nuestro cliente puede \textit{decir} a qué fragmento pertenece.

Para una futura versión de este \textit{cliente} dicha funcionalidad podría ser utilizada para definir una estrategia particular de resolución de las consultas. Por ejemplo, si el \textit{programa} perteneciera al fragmento \textit{lineal} se podría llamar a un servicio de reescritura que reescriba las consultas tal como se describió en la figura \ref{fig:fo_rewrite} de la sección \textit{First-order rewritability} y una vez obtenida la reescritura enviar tales consultas a un motor de base de datos \textit{SQL}.

\subsubsection{Validación de consistencia}

El cliente provee también la posibilidad de validar la consistencia de un \textit{programa} sin necesidad de ejecutar consultas. En este caso, cuando el usuario haga \textit{click} en el botón \textit{Check Consistency}, el \textit{cliente} aramará un \textit{json} con la misma estructura que se muestra en la figura \ref{fig:query_endpoint} donde el campo \textit{queries} será un campo vacío. De esta manera, en caso de que el programa fuera inconsistente, la \textit{Api Web} retornara una respuesta con el formato que se muestra en la figura \ref{fig:query_endpoint_answer_2}, indicando los índices de las restricciones que no se cumplieron en el arreglo enviado por el cliente en el campo \textit{ncs}. El \textit{cliente} mantendrá una estructura de \textit{diccionario} que indicará a cual número de línea de texto en el programa ingresado corresponde cada índice de \textit{restricción} enviada en la petición. De esta manera se marcarán en color verde aquellas \textit{restricciones} o \textit{claves} que violen la consistencia, tal como se muestra en la figura  \ref{fig:cliente_web_iar_ar}.


\begin{figure}[ht]
    \includegraphics[scale=0.5]{cliente_web_iar_ar.PNG}
    \centering
    \caption{Ejecuar bajo AR - IAR}
    \label{fig:cliente_web_iar_ar}
\end{figure}

Vemos que además en este caso aparecen dos nuevos botones que brindarán la posibilidad de ejecutar las consultas bajo la semántica \textit{AR} o \textit{IAR} más un nuevo botón que brindará la posibilidad de mostrar el conjunto de \textit{repairs} para el \textit{programa} ingresado.

\subsubsection{Ejecutando consultas}

Cuando el usuario presione en el botón \textit{Execute Queries} tal como se muestra en la figura \ref{fig:cliente_web_2}, se enviará el \textit{json} a la \textit{api web} tal como se muestra en la figura \ref{fig:query_endpoint}. Hay dos posibilidades, o bien el programa es consistente o bien no lo es. En el primer caso se mostrarán las respuestas para cada consulta tal como se muestra en la figura \ref{fig:cliente_web_2}. En el segundo caso, se ocultará el botón de \textit{Execute Queries} y se mostrarán los dos botones que brindan la posibilidad de ejecutar consultas bajo semántica \textit{AR} o \textit{IAR}. Al presionar alguno de esos botones se mostrarán ahora sí los resultados de ejecutar la consultas bajo la semántica elegida.

\subsubsection{Manejo de error de timeout}
En el caso en el que el servidor responda con error de \textit{timeout} o en el caso en el que el servidor tarde demasiado en responder\footnote{El \textit{cliente} definirá por configuración cuanto tiempo está dispuesto a esperar la respuesta del servidor.}, se le ofrecerá al usuario la posibilidad de definir la máxima cantidad de iteraciones a ejecutar en el algoritmo del \textit{chase}. De esta manera, el \textit{cliente} hará una segunda petición al servidor pero asignándole al campo \textit{max\_depth} el valor ingresado por el usuario.

%%%% BIBLIOGRAFIA
\backmatter
\begin{thebibliography}{9}
    \bibitem{beeri} 
    C. Beeri y M. Y. Vardi.
    \textit{The implication problem for data dependencies}. 
    En \textit{Proc. ICALP-1981}, pp. 73–85, 1981.
     
    \bibitem{cali} 
    A. Calı, G. Gottlob, y M. Kifer.
    Taming the infinite chase: Query answering under expressive relational constraints.
    En \textit{Proc. KR-2008, pp. 70–80, 2008}. 

    \bibitem{Chandra} 
    A. K. Chandra and P. M. Merlin. 
    Optimal implementation of conjunctive queries in relational data bases.
    En \textit{Proc. KR-2008, pp. 70–80, 2008}. 

    \bibitem{Deutsch} 
    A. Deutsch, A. Nash, and J. B. Remmel.
    The chase revisited.
    En \textit{Proc. PODS-2008, pp. 149–158, 2008}. 

    \bibitem{Fagin} 
    R. Fagin, P. G. Kolaitis, R. J. Miller, and L. Popa.
    Data exchange: Semantics and query answering.
    En \textit{Theor. Comput. Sci., 336(1):89–124, 2005.}. 

    \bibitem{Johnson} 
    D. S. Johnson and A. C. Klug.
    Testing containment of conjunctive queries under functional and inclusion dependencies.
    En \textit{J. Comput. Syst. Sci., 28(1):167–189, 1984}. 

    \bibitem{Vardi} 
    M. Y. Vardi
    On the complexity of bounded-variable queries.
    En \textit{Proc. PODS-1995, pp. 266–176, 1995}. 
    
    \bibitem{JWS} 
    Andrea Calì, Georg Gottlobc, Thomas Lukasiewicz.
    A General Datalog-Based Framework for Tractable Query Answering over Ontologies
    En \textit{QUE PONGO ACA}. 
    
    \bibitem{Huang} 
    Z. Huang, F. van Harmelen, and A. ten Teije.
    Reasoning with inconsistent ontologies.
    En \textit{Proc. of IJCAI 2005, pages 454–459, 2003}. 
    
    \bibitem{Hitzler} 
    Y. Ma and P. Hitzler.
    Paraconsistent reasoning for owl 2.
    En \textit{Proc. of RR 2009, pages 197–211, 2009.} 
    
    \bibitem{Parsia} 
    B. Parsia, E. Sirin, and A. Kalyanpur.
    Debugging OWL ontologies.
    En \textit{Proc. of WWW 2005, pages 633–640, 2005.} 

    \bibitem{Haasa} 
    P. Haasa, F. van Harmelen, Z. Huang, H. Stuckenschmidt, y Y. Sure.
    A framework for handling inconsistency in changing ontologies.
    En \textit{Proc. of ISWC 2005, 2005.} 

    \bibitem{Lembo} 
    D. Lembo and M. Ruzzi.
    Consistent query answering over description logic ontologies.
    En \textit{Proc. of RR 2007, 2007.} 
    
    \bibitem{Eiter} 
    T. Eiter and G. Gottlob.
    On the complexity of propositional knowledge base revision, updates and counterfactuals.
    En \textit{Artificial Intelligence, 57:227–270, 1992.} 
    
    \bibitem{Winslett} 
    M. Winslett.
    Updating Logical Databases.
    En \textit{Cambridge University Press, 1990} 
    
    \bibitem{Kewen} 
    Zhe Wang, Peng Xiao, and Kewen Wang.
    Practical Datalog Rewriting for Existential Rules
    En \textit{Griffith University, Australia} 
    
    \bibitem{Gottlob} 
    Georg Gottlob, Giorgio Orsi, and Andreas Pieris.
    Ontological Queries: Rewriting and Optimization
    En \textit{Department of Computer Science, University of Oxford. Oxford-Man Institute of Quantitative Finance, University of Oxford, UK. Institute for the Future of Computing, University of Oxford, UK } 





    \end{thebibliography}

\end{document}
